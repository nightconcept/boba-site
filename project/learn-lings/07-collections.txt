# Lesson: 07-collections

While primitive types are the basic building blocks for data, most real-world programs need to work with collections of data. Boba provides two primary, built-in collection types for this purpose: `list` and `map`.

### `list`

A `list` is an ordered collection of values of the same type. Lists are dynamic, meaning you can add or remove items.

```boba
// A list of numbers
var highScores: int[] = [100, 95, 80]

// A list of strings
var ingredients: string[] = ["flour", "sugar", "boba pearls"]
```

Lists declared with `let` are immutable, meaning their contents cannot be changed after creation. If you try to modify a list created with `let`, the Boba compiler will report an error.

```boba
let starting_gear: string[] = ["tunic", "dagger"]
// starting_gear.push("shield") // This would cause a compile error because the list is immutable.
```

You can perform many operations on lists, like getting their size or adding new items.

```boba
print(ingredients.len()) // Outputs: 3

// Add a new item to the end
ingredients.push("tapioca pearls")
print(ingredients.len()) // Outputs: 4

// Access items by their index (starting from 0)
print(ingredients[0]) // Outputs: "flour"

Boba lists are "zero-indexed," which means the first item is at index 0, the second at index 1, and so on.
```

### `map`

A `map` is a collection of key-value pairs. Think of a map like a dictionary, where each 'key' is a unique word and the 'value' is its definition. Each key must be unique, and all keys must be of the same type, as must all values.

```boba
// Create a map with string keys and number values
var scores: [string:int] = {
  "ada": 100,
  "grace": 95
}

// Check its initial size
print(scores.len()) // Outputs: 2

// Insert a new key-value pair
scores["boba"] = 105

// Check the new size
print(scores.len()) // Outputs: 3
```

To read a value from a map, you use square brackets `[]` with the key.

```boba
let adas_score = scores["ada"]
print(f"Ada's score is: {adas_score}") // Outputs: Ada's score is: 100
```

But what happens if you try to access a key that doesn't exist? In many languages, this can lead to unexpected crashes (like a `KeyError` in Python) or silent errors (like returning `undefined` in JavaScript). Boba prevents these problems. Accessing a key in a map doesn't return the value directly. Instead, it returns a special `Option` type, which safely handles cases where the key might not exist. We will cover this powerful feature in a later chapter.

================================================================================

# Bobalings Exercises for Chapter 07

--- Exercise: exercises/07_collections/list1.boba ---

//! A `list` is an ordered collection of values of the same type.
//! When you declare a list, you must specify the type of its elements
//! using the `Type[]` syntax.
//!
//! For example, a list of integers is `int[]`, and a list of strings
//! is `string[]`.
//!
//! Your task is to add the correct type annotation to the list.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn main() {
  // This list of numbers is missing its type annotation.
  // Add the correct type annotation to the `numbers` variable.
  // It should be `let numbers: int[] = [10, 20, 30];`
  let numbers = [10, 20, 30];

  print(f"The first number is: {numbers[0]}");
}

--- Exercise: exercises/07_collections/list2.boba ---

//! Lists in Boba are dynamic, meaning you can add or remove items.
//! To add an element to the end of a list, you use the `.push()` method.
//!
//! Note that to modify a list, it must be declared as mutable with `var`.
//!
//! Your task is to add an element to the list.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn main() {
  // This list is mutable, so we can add to it.
  var ingredients: string[] = ["flour", "sugar"];

  // Use the `.push()` method to add "boba pearls" to the `ingredients` list.
  // The call should look like: `ingredients.push("boba pearls");`
  /* your code here */

  print(f"The ingredients are: {ingredients}");
}

--- Exercise: exercises/07_collections/list3.boba ---

//! You can access individual elements of a list by their index, which is
//! their position in the list.
//!
//! List indexing starts at 0. So, the first element is at index `[0]`, the
//! second at index `[1]`, and so on.
//!
//! Your task is to access an element from the list using its index.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn main() {
  let high_scores: int[] = [100, 95, 80];

  // The code below tries to print the first high score.
  // Access the first element of the `high_scores` list using index `[0]`.
  // The expression should be `high_scores[0]`.
  let first_score = /* your code here */;

  print(f"The first high score is: {first_score}");
}

--- Exercise: exercises/07_collections/map1.boba ---

//! A `map` is a collection of key-value pairs.
//! When you declare a map, you must specify the type of its keys and values
//! using the `[KeyType:ValueType]` syntax.
//!
//! For example, a map from strings to integers is `[string:int]`.
//!
//! Your task is to add the correct type annotation to the map.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn main() {
  // This map of player scores is missing its type annotation.
  // The keys are strings and the values are integers.
  // Add the correct type annotation: `[string:int]`.
  let scores = {
    "ada": 100,
    "grace": 95
  };

  print(f"Ada's score is: {scores["ada"]}");
}

--- Exercise: exercises/07_collections/map2.boba ---

//! To add a new key-value pair to a map, you use the syntax
//! `my_map[key] = value`.
//!
//! If the key already exists, its value will be updated. If it doesn't
//! exist, the new key-value pair will be inserted.
//!
//! Remember, to modify a map, it must be declared as mutable with `var`.
//!
//! Your task is to insert a new key-value pair into the map.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn main() {
  var scores: [string:int] = {
    "ada": 100,
  };

  // Insert a new score for "boba" with a value of 105.
  // The syntax is `scores["boba"] = 105;`
  /* your code here */

  print(f"The scores are: {scores}");
}

--- Exercise: exercises/07_collections/map3.boba ---

//! Both `list` and `map` have a `.len()` method that returns the number
//! of elements in the collection as an integer.
//!
//! Your task is to use the `.len()` method to get the size of a list and a map.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn main() {
  let my_list: int[] = [1, 2, 3, 4];
  let my_map: [string:string] = {"a": "apple", "b": "banana"};

  // Call the `.len()` method on `my_list` to get its length.
  let list_length = /* your code here */;
  print(f"The list has {list_length} elements.");

  // Call the `.len()` method on `my_map` to get its length.
  let map_length = /* your code here */;
  print(f"The map has {map_length} elements.");
}

