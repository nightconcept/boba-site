# Lesson: 16-defer-and-panic

## Guaranteed Cleanup with `defer`

The `defer` statement schedules a function call to be executed right before the current function exits, regardless of whether the function returns normally, propagates an error with the `?` operator, or exits due to a `panic`.

```boba
pub fn process_file(path: string) -> Result<string, error> {
    // 1. Open the file. If this fails, we exit, no cleanup needed.
    var file = fs.open(path)?

    // 2. Defer the close call *immediately* after opening.
    // This is now GUARANTEED to run when process_file exits.
    defer file.close()

    // 3. Now, we can focus on the logic without worrying about cleanup.
    var data = file.read_all()?
    if data.is_empty() {
        // We can just return. `defer file.close()` will run automatically.
        return Err({ message = "File is empty" })
    }

    // `defer file.close()` will also run automatically before this return.
    return Ok("Processed data!")
}

If a function has multiple `defer` statements, they are executed in **Last-In, First-Out (LIFO)** order. The last `defer` scheduled is the first one to run when the function exits. This is a crucial rule for correct resource management when multiple resources are acquired.

## Unrecoverable Errors with `panic`

Whereas `Result` is used for expected, recoverable errors, `panic` is reserved for unrecoverable errors that signify a bug in the program's logic. A panic is an abrupt, unrecoverable error that stops the normal execution of your program. `panic` must not be used for ordinary, expected errors like a file not being found or invalid user input; those are cases where `Result` is the appropriate tool.

When a panic occurs, the program will stop what it's doing and begin to **unwind the stack**. As it unwinds, it will execute any **`defer`** statements it finds along the way.

You can trigger a panic manually with the built-in `panic()` function.

```boba
fn get_guild_rank(player: Player) -> string {
  // This function assumes the player is in a guild.
  let rank_option = player.guild_rank() // Returns Option<string>

  match rank_option {
    Some(rank) => return rank,
    None => {
      // If we get here, it means another part of our code called this
      // function with a player who wasn't in a guild. This is a bug.
      panic(f"Critical error: get_guild_rank called on non-guild member {player.name}!")
    }
  }
}
### Time to Practice!

It's time to practice what you've learned. The next exercises will challenge you to refactor a function to use `defer` for resource cleanup and write a function that correctly panics when its input violates a critical precondition.

================================================================================

# Bobalings Exercises for Chapter 16

--- Exercise: exercises/16_resource_management/defer1.boba ---

//! The `defer` statement schedules a function call to be executed right
//! before the current function exits, no matter how it exits. This is
//! perfect for guaranteeing cleanup, like closing a file.
//!
//! Your task is to use `defer` to ensure a resource is always released.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn process_resource() -> Result<string, string> {
  print("Acquiring resource...");
  // In a real program, this would be a file handle or network connection.
  let resource = "my_resource";

  // This cleanup action needs to run no matter what.
  // Use `defer` to schedule the `release_resource` call.
  // The statement should be: `defer release_resource(resource);`


  let should_fail = true;
  if should_fail {
    return Err("Something went wrong during processing.");
  }

  return Ok("Resource processed successfully.");
}

fn release_resource(resource: string) {
  print(f"Releasing resource: {resource}");
}

fn main() {
  process_resource();
}

--- Exercise: exercises/16_resource_management/defer2.boba ---

//! When you have multiple `defer` statements in a function, they are
//! executed in Last-In, First-Out (LIFO) order. Think of it as a stack
//! of cleanup tasks.
//!
//! Your task is to predict the LIFO execution order of the `defer` statements.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn main() {
  var order: string[] = [];

  print("Start");
  defer order.push("first");
  defer order.push("second");
  defer order.push("third");
  print("End");

  // Because of LIFO order, the deferred calls will run as:
  // 1. order.push("third")
  // 2. order.push("second")
  // 3. order.push("first")
  //
  // The final `order` list will be `["third", "second", "first"]`.
  // The assertion below is incorrect. Fix it.
  test.assert_eq(order, ["first", "second", "third"]);
}

--- Exercise: exercises/16_resource_management/panic1.boba ---

//! A `panic` is an unrecoverable error that stops the program. You should
//! use it when your code reaches a state that should be logically impossible,
//! indicating a bug.
//!
//! Your task is to add a `panic!` to handle an impossible situation.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn calculate_average(numbers: int[]) -> float {
  // It's impossible to calculate the average of an empty list.
  // This represents a bug in the code that *calls* this function.
  //
  // Add a check here to see if the `numbers` list is empty.
  // If it is, `panic!` with a helpful message.
  // e.g., `if numbers.len() == 0 { panic("Cannot calculate average of empty list!"); }`

  var sum = 0;
  for n in numbers {
    sum += n;
  }
  return sum as float / numbers.len() as float;
}

fn main() {
  // This call is incorrect and should cause the program to panic.
  calculate_average([]);
}

