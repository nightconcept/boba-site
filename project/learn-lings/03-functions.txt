# Lesson: 03-functions

Functions are blocks of code that you can name and call from other parts of your program. They are essential for organizing your code and making it reusable.

## Defining and Calling Functions

You define a function using the `fn` keyword. You can also specify the types of the arguments and the return value.

```boba
// A simple function that takes no arguments and returns nothing.
fn say_hello() {
  print("Hello, Boba!")
}

// Call the function
say_hello()
```

### Functions with Return Values
To have a function return a value, you must declare its type after an arrow (`->`). Inside the function, you use the `return` keyword to send the value back to the code that called it.

```boba
fn get_greeting(name: string) -> string {
  return f"Hello, {name}!"
}

let message = get_greeting(name: "Boba")
print(message) // Outputs: Hello, Boba!
```

## Function Calls: Mandatory Named Arguments

A common source of subtle bugs in many languages occurs when arguments are passed to a function in the wrong order. For example, a function call like `create_user("Admin", 123)` might silently succeed when the function actually expected `(id: int, role: string)`. Boba solves this problem by requiring named arguments by default.

To maximize clarity, Boba requires function arguments to be called with their names by default. This makes function call sites self-documenting. This approach is built into the language to achieve the clarity that developers in other languages like JavaScript or Python often simulate by passing a single 'options' object to a function.

### The Default: Named Arguments

All arguments at a function call site _must_ be called with their name, using a colon (`:`) as a separator.

```boba
// This function requires named arguments.
pub fn connect(host: string, port: int, timeout: int) { /* ... */ }

// Correct call:
connect(host: "boba.dev", port: 9000, timeout: 5000)

// COMPILE ERROR: Positional arguments not allowed for this function.
// connect("boba.dev", 9000, 5000)
```

### Opting-In to Positional Arguments

For a parameter to be callable positionally, its name in the function _declaration_ must be prefixed with an underscore (`_`). The function's author uses this to signal that the argument's order is natural and unambiguous, like the operands in an addition function.

```boba
// This function allows positional arguments.
pub fn add(_ a: int, _ b: int) -> int { return a + b }

// Correct calls:
add(5, 3)
add(a: 5, b: 3) // Named calls are still allowed for clarity.
```

### Controlling Visibility: Public vs. Private Functions

Now that you know how to define a function, it's important to understand who can call it. Boba is designed for safety and clear organization, so it has a simple rule: by default, everything you create is private.

When a function is private, it means it can only be seen and used by code within the very same file where it is defined. It is completely invisible to the outside world. This is a powerful feature that lets you write internal helper functions without worrying that they will be used incorrectly by other parts of a large program.

To make a function part of a file's public API so that it can be used by other files, you must explicitly mark it as public using the pub keyword at the beginning of its definition.

You can think of it like building a house:
- A private function (the default) is like a bedroom or a utility closet—it's essential for the house to work, but it's only meant to be used by the people living inside.
- A public function (marked with pub) is like the front door or the mailbox—it's the official, designated way for guests and visitors to interact with the house from the outside.

You may have noticed the pub keyword in some of the previous examples. This new understanding explains why it was there: those functions were being designed as public, reusable tools. This concept of public versus private will apply to other things you create later, such as structs and enums.

### Mixing Named and Positional Arguments

If a function has both positional and named arguments, all positional arguments must come first.

```boba
// This function mixes positional and named arguments.
pub fn create_user(_ id: int, name: string, is_admin: boolean) { /* ... */ }

// Correct call: Positional arguments first.
create_user(101, name: "Ada", is_admin: false)

// COMPILE ERROR: Positional argument cannot follow a named argument.
// create_user(name: "Ada", 101, is_admin: false)
```

### Default Parameters
You can make function arguments optional by providing a default value. This is done by adding `= value` after the parameter's type. If the argument is omitted in the function call, the default value is used.

```boba
fn connect(host: string, port: int = 8080, use_tls: boolean = true) {
  print(f"Connecting to {host}:{port} (TLS: {use_tls})")
}

connect(host: "boba.dev") // Uses default port and TLS setting
connect(host: "boba.dev", port: 9000) // Overrides port, uses default TLS
```

### Chaining Functions with the Pipe Operator

Boba includes a special pipe operator (`|>`) to make chaining function calls more readable. It takes the result of the expression on its left and passes it as the first argument to the function on its right.

This operator is purely for developer ergonomics. It transforms deeply nested calls that must be read "from the inside-out" into a linear sequence of steps that can be read "from left-to-right," which more closely matches how we think about a data transformation pipeline.

Consider a set of functions to process text:

```boba
fn trim(s: string) -> string { /* ... */ }
fn to_uppercase(s: string) -> string { /* ... */ }
fn emphasize(s: string) -> string { f"**{s}**" }
```

Without the pipe operator, processing a message requires nesting the calls, which is read from the inside out and can be hard to follow:

```boba
let message = "  hello world  "
let formatted = emphasize(to_uppercase(trim(message)))
// formatted is "**HELLO WORLD**"
```

With the pipe operator, you can express the same logic as a clear, left-to-right sequence of transformations:

```boba
let message = "  hello world  "
let formatted = message |> trim() |> to_uppercase() |> emphasize()
// formatted is "**HELLO WORLD**"
```

The pipe operator is especially powerful when combined with functions that take both positional and named arguments. It passes its result as the first positional argument, allowing you to cleanly chain operations that feed into more complex functions.

```boba
// From our previous example of a mixed-argument function
fn create_user(_ id: int, name: string, is_admin: boolean) {
  print(f"Creating user {id}: {name} (Admin: {is_admin})")
}

let user_id = 101

// The pipe passes `user_id` as the first argument to `create_user`
user_id |> create_user(name: "Ada", is_admin: false)
// Outputs: Creating user 101: Ada (Admin: false)
```

This style is a cornerstone of functional programming and is highly encouraged in Boba for creating readable data processing pipelines.

================================================================================

# Bobalings Exercises for Chapter 03

--- Exercise: exercises/03_functions/functions1.boba ---

//! In Boba, you can define your own functions to reuse code.
//! A function is defined with the `fn` keyword, followed by its name,
//! a pair of parentheses `()`, and a code block `{}`.
//!
//! The compiler will tell you if you try to call a function that
//! hasn't been defined.
//!
//! Your task is to define the `call_me` function.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn main() {
  // The `call_me` function is called here, but it doesn't exist yet.
  // Define it below the `main` function.
  call_me();
}

// Define the `call_me` function here.
// It should look like this:
// fn call_me() {
//   // The body can be empty for this exercise.
// }

--- Exercise: exercises/03_functions/functions2.boba ---

//! Functions can accept arguments (also called parameters) to work with data.
//! You must declare the name and type of each parameter in the function's
//! signature.
//!
//! The compiler will check that you pass the correct number and type of
//! arguments when you call a function.
//!
//! Your task is to add a parameter to the `greet` function.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn main() {
  // The `greet` function is called with a name, but its definition
  // doesn't accept any arguments yet.
  greet(name: "Boba");
}

// Add a `name` parameter of type `string` to this function's signature.
// It should look like this: `fn greet(name: string)`
fn greet() {
  print(f"Hello, {name}!");
}

--- Exercise: exercises/03_functions/functions3.boba ---

//! Functions can return values to the code that calls them.
//! To do this, you must specify the return type in the function's signature
//! using the `->` syntax, and use the `return` keyword to send a value back.
//!
//! The compiler will tell you if a function's return value is used but
//! the function doesn't actually return anything.
//!
//! Your task is to make the `square` function return a value.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn main() {
  let number = 5;
  // The result of `square(number)` is used here, but the function
  // doesn't return anything yet.
  let squared_number = square(number);
  print(f"The square of {number} is {squared_number}");
}

// This function needs to return an `int`.
// 1. Add `-> int` to the function signature.
// 2. Add `return n * n;` to the function body.
fn square(n: int) {
  // calculate and return the square of n
}

--- Exercise: exercises/03_functions/functions4.boba ---

//! To improve clarity, Boba requires that you use named arguments when
//! calling a function with multiple parameters. This makes your code
//! self-documenting.
//!
//! Instead of `my_func(value1, value2)`, you must write
//! `my_func(param1: value1, param2: value2)`.
//!
//! Your task is to fix the function call to use named arguments.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn main() {
  // This function call uses positional arguments, which is not allowed.
  // Change the call to use named arguments: `create_user("Ada", 101)`
  // should become `create_user(name: "Ada", id: 101)`.
  create_user("Ada", 101);
}

fn create_user(name: string, id: int) {
  print(f"Created user {name} with ID {id}");
}

--- Exercise: exercises/03_functions/functions5.boba ---

//! Functions can have default parameters, which makes them more flexible.
//! If a parameter has a default value, you can omit it from the function call.
//!
//! You define a default parameter with the syntax `param_name: type = default_value`.
//!
//! Your task is to add a default parameter to the `connect` function.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn main() {
  // This function call is missing the `port` argument.
  // The compiler will complain about a missing argument.
  connect(host: "my-boba-server.com");
}

// Add a default value to the `port` parameter to make it optional.
// Change `port: int` to `port: int = 8080`.
fn connect(host: string, port: int) {
  print(f"Connecting to {host} on port {port}...");
}

