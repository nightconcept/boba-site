# Lesson: 09-structs

Structs, short for structures, are custom data types you can create by grouping together related variables. Think of a struct definition as a blueprint: it defines the shape and fields for a concept in your program. From that blueprint, you can then create multiple concrete instances.

## Defining a Struct

You define a struct using the `struct` keyword. Inside the struct definition, you list the variables (called fields) that make up the struct.

```boba
// Define a `Player` struct
struct Player {
  name: string,
  score: int,
  is_active: boolean
}
```

## Creating an Instance of a Struct

Once you have defined a struct, you can create instances of it using a struct literal.

```boba
// Create a new variable `ada` of type `Player`
let ada: Player = { name: "Ada", score: 100, is_active: true }
```

## Accessing Struct Fields

You can access the fields of a struct instance using dot notation.

```boba
print(f"Player name: {ada.name}") // Prints "Player name: Ada"
```

### Composing Structs

The real power of structs becomes apparent when you use them to build more complex data structures. A struct's fields can be of any type, including other structs you have defined. This is called composition.

```boba
struct Point {
  x: int,
  y: int,
}

struct Line {
  start: Point, // This field is another struct
  end: Point,   // This one too
}

let my_line = Line {
  start: Point { x: 10, y: 20 },
  end: Point { x: 50, y: 30 },
}

// You can chain dot notation to access nested fields
print(f"The line starts at x = {my_line.start.x}")
```

### Field Visibility and the `pub` Keyword

By default, all fields in a struct are **private**. This means they can only be accessed by code in the same file where the struct is defined. This is a core principle of encapsulation, preventing external code from relying on the internal structure of your data.

To make a field part of the struct's public API, you must explicitly mark it with the `pub` keyword.

Think of it like a building: some rooms (private fields) are for internal staff only, while the reception area (`pub` fields) is accessible to the public.

This principle of encapsulation allows the author of a struct to later refactor or change the internal, private fields without breaking the code of users who depend on it, as long as the public API (the `pub` fields) remains consistent.

```boba
// in a file named `user.boba`

pub struct User {
  pub id: int,      // This field is public and can be accessed from other files.
  username: string, // This field is private to `user.boba`.
  email: string,    // This is also private.
}
```

If you tried to access `some_user.username` from a different file, the compiler would stop you, enforcing the privacy rules you've defined.

### Mutating a Struct
To create a mutable instance whose fields you can modify, you must declare the variable using `var`. If a struct instance is bound using `let`, it is deeply immutableâ€”neither the variable can be reassigned, nor can its fields be changed.
```boba
// Create a mutable Player instance
var boba_dev: Player = { name: "Boba Dev", score: 0, is_active: false }
print(f"Initial score: {boba_dev.score}") // Outputs: Initial score: 0

// Mutate the score field
boba_dev.score = 150
print(f"Updated score: {boba_dev.score}") // Outputs: Updated score: 150
```

### Creating a New Struct from an Old One

Often, instead of mutating a struct, you'll want to create a new instance based on an old one but with some fields changed. Boba provides a convenient struct update syntax for this. The .. operator specifies that the remaining unmentioned fields should be copied directly from another instance.

```boba
let player1 = Player { name: "Ada", score: 100, is_active: true }

// Create player2 based on player1, but with a different score.
// The `name` and `is_active` fields are copied from player1.
let player2 = Player { score: 150, ..player1 }

print(f"{player2.name} has a new score of {player2.score}")
```

### Time to Practice!

You now know how to bundle related data together. This is the first half of creating powerful custom types. In the next chapter, we will bring this data to life by giving our structs behavior with methods.

================================================================================

# Bobalings Exercises for Chapter 09

--- Exercise: exercises/09_structs/structs1.boba ---

//! A `struct` is a custom data type that lets you group together related
//! variables. Think of it as a blueprint for a concept in your program.
//!
//! To create an instance of a struct, you use a struct literal, which looks
//! like `{ field1: value1, field2: value2 }`.
//!
//! Your task is to create an instance of the `Player` struct.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

struct Player {
  name: string,
  score: int,
  is_active: boolean,
}

fn main() {
  // The `player1` variable is declared but not initialized.
  // Create an instance of the `Player` struct with the following data:
  // name: "Ada"
  // score: 100
  // is_active: true
  let player1: Player = /* your code here */;

  print(f"Player {player1.name} has a score of {player1.score}.");
}

--- Exercise: exercises/09_structs/structs2.boba ---

//! The definition of a `struct` acts as a strict blueprint.
//! You can only instantiate a struct with the exact fields that are
//! defined in its block.
//!
//! The compiler will give you an error if you try to use a field that
//! isn't part of the struct's definition.
//!
//! Your task is to add a missing field to the `Player` struct definition.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

// The `Player` struct is missing a field.
// The instantiation below uses a `level` field, but it's not defined here.
// Add `level: int,` to the struct definition.
struct Player {
  name: string,
  score: int,
}

fn main() {
  let player1 = Player {
    name: "Boba",
    score: 100,
    level: 5, // This line causes the error.
  };

  print(f"Player {player1.name} is at level {player1.level}.");
}

--- Exercise: exercises/09_structs/structs3.boba ---

//! Once you have an instance of a struct, you can access its fields
//! using dot notation.
//!
//! For example, if you have a variable `player1` of type `Player`, you can
//! get its name with `player1.name`.
//!
//! Your task is to use dot notation to access a struct field.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

struct Player {
  name: string,
  score: int,
}

fn main() {
  let player1 = Player { name: "Grace", score: 95 };

  // The code below needs to get the player's score.
  // Use dot notation to access the `score` field from `player1`.
  let current_score = /* your code here */;

  print(f"The player's score is: {current_score}");
}

--- Exercise: exercises/09_structs/structs4.boba ---

//! Structs can be composed, meaning a struct can contain another struct
//! as one of its fields. This allows you to build complex data structures.
//!
//! Your task is to instantiate a struct that contains other structs.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

struct Point {
  x: int,
  y: int,
}

struct Line {
  start: Point,
  end: Point,
}

fn main() {
  // Create a `Line` struct. To do this, you'll need to create two `Point`
  // structs for its `start` and `end` fields.
  // The start point should be at (10, 20).
  // The end point should be at (30, 40).
  let my_line = Line {
    start: /* a Point struct here */,
    end: /* another Point struct here */,
  };

  print(f"The line starts at ({my_line.start.x}, {my_line.start.y})");
}

