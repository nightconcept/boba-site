# Lesson: 11-modules

As your programs grow larger, it becomes important to organize your code into multiple files. In Boba, the module system is designed to be simple and intuitive. The rules are:

1.  **Every file is a module.** Each `.boba` file you create is its own module, a private container for its contents.
2.  **Items are private by default.** All items you define in a file—functions, structs, enums, etc.—are private to that module. They can only be used within the same file.
3.  **Use `pub` to create a public API.** To make an item accessible from other modules, you must explicitly mark it with the `pub` keyword. This makes it part of the module's public API.
4.  **Use `import` to access public items.** The `import` keyword is the mechanism to use public items from one module in another.

For the following examples, assume you have two files, `utils.boba` and `main.boba`, located together in the same directory.

## Importing Specific Items

To import specific items from a file, you use the `import { item } from "path"` syntax. You can list items by name inside curly braces `{}`, and can optionally rename them with `as`.

```boba
// in utils.boba
pub fn say_hello() {
    print("Hello!")
}
pub fn say_goodbye() {
    print("Goodbye!")
}

// in main.boba
// The `./` is important! It tells Boba to look in the current directory.
import { say_hello, say_goodbye as farewell } from "./utils.boba"

say_hello() // Prints "Hello!"
farewell() // Prints "Goodbye!"
```

File paths can also point to files in subdirectories, such as "./helpers/strings.boba".

## Importing Everything as a Namespace

To import all public items from a file as a single namespace, you can use the `import * as namespace from "path"` syntax.

```boba
// in utils.boba
pub fn say_hello() {
    print("Hello!")
}
pub fn say_goodbye() {
    print("Goodbye!")
}

// in main.boba
// The `import * as ...` syntax imports all public items under a single namespace.
import * as utils from "./utils.boba"

utils.say_hello()
utils.say_goodbye()

================================================================================

# Bobalings Exercises for Chapter 11

--- Exercise: exercises/11_modules/modules1.boba ---

//! To use functions, structs, or other items from another file, you must
//! import them using the `import` keyword.
//!
//! To import a specific item, you use the syntax:
//! `import { itemName } from "./path/to/file.boba";`
//!
//! Your task is to import the `say_hello` function from the `utils.boba` file.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

// This file needs to use the `say_hello` function from `utils.boba`.
// Add an import statement at the top of this file to import `say_hello`.
// The import should look like: `import { say_hello } from "./utils.boba";`

fn main() {
  say_hello();
}

--- Exercise: exercises/11_modules/modules2.boba ---

//! By default, all items in a Boba file are private, meaning they can
//! only be used within that same file.
//!
//! To make an item (like a function or struct) usable from other files,
//! you must make it public by using the `pub` keyword.
//!
//! Your task is to make the `say_goodbye` function public.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

import { say_goodbye } from "./utils2.boba";

// This file imports `say_goodbye` from `utils2.boba`, but the function
// is private in that file.
// Go to `exercises/11_modules/utils2.boba` and add the `pub` keyword
// to the `say_goodbye` function definition to make it public.
// It should look like: `pub fn say_goodbye() { ... }`

fn main() {
  say_goodbye();
}

--- Exercise: exercises/11_modules/modules3.boba ---

//! Sometimes you might import an item that has the same name as an item
//! already in your current scope. To avoid this naming conflict, you can
//! rename an imported item using the `as` keyword.
//!
//! The syntax is: `import { originalName as newName } from "./file.boba";`
//!
//! Your task is to rename the imported `greet` function.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

// This file already has a `greet` function.
// To avoid a conflict with the one from `utils3.boba`, rename the
// imported function to `say_hello`.
// The import should look like: `import { greet as say_hello } from "./utils3.boba";`
import { greet } from "./utils3.boba";

fn greet() {
  print("Hello from the main file!");
}

fn main() {
  // Call the renamed function, which should now be `say_hello`.
  say_hello();
}

--- Exercise: exercises/11_modules/modules4.boba ---

//! Instead of importing items one by one, you can import an entire file
//! as a single namespace. This is useful when a file provides many related
//! functions.
//!
//! The syntax is: `import * as namespace from "./file.boba";`
//!
//! You then access the imported items using the namespace as a prefix,
//! for example: `namespace.my_function()`.
//!
//! Your task is to import the `utils4.boba` file as a namespace.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

// Import everything from `utils4.boba` into a namespace called `utils`.
// The import should look like: `import * as utils from "./utils4.boba";`
/* your import here */

fn main() {
  // Call `func1` from the `utils` namespace.
  // The call should look like: `utils.func1();`
  /* your code here */
}

--- Exercise: exercises/11_modules/utils.boba ---

//! This is a utility file.
//! It contains a function that can be used by other files.

pub fn say_hello() {
  print("Hello from the utils file!");
}

--- Exercise: exercises/11_modules/utils2.boba ---

//! This is another utility file.

// This function is private by default.
fn say_goodbye() {
  print("Goodbye from the utils2 file!");
}

--- Exercise: exercises/11_modules/utils3.boba ---

//! This is a utility file with a generic function name.

pub fn greet() {
  print("A generic greeting!");
}

--- Exercise: exercises/11_modules/utils4.boba ---

//! A utility file with multiple public functions.

pub fn func1() {
  print("This is function 1.");
}

pub fn func2() {
  print("This is function 2.");
}

