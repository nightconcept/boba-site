# Lesson: 08-enums

While Boba provides powerful built-in enums like `Option` and `Result`, one of its key features is the ability to define your own. An **enum** (short for enumeration) is a custom type that can only be one of a specific, fixed set of possible values, called 'variants'.

This is incredibly useful for modeling state. For example, if you are tracking the status of a job, you can define an enum to ensure the status can *only* be one of the states you've defined, preventing bugs from invalid string values.

### Defining an Enum

You define an enum with the `enum` keyword, listing all its possible variants.

```boba
// This enum can only be one of three possible values.
enum JobStatus {
  Pending,
  Complete,
  Failed
}
```

> **Pro-Tip: Enums with Data**
>
> In Boba, enum variants can also hold data. For example, you could define `Failed(string)` to store an error message right inside the variant. This powerful feature for modeling complex state will be covered in a later chapter.

### Using an Enum

Once defined, you can use the enum as a type for variables and function parameters. You access a specific variant using `EnumName.VariantName`.

To act on the value of an enum, you can use a `match` statement. This is a powerful control flow tool that allows you to compare a value against a series of patterns and execute code based on which pattern matches. Its key feature is that it must be exhaustiveâ€”the compiler guarantees that you have a branch for every possible variant, preventing bugs from unhandled cases.

```boba
// Create a variable of type JobStatus.
let current_status: JobStatus = JobStatus.Pending

match current_status {
  JobStatus.Pending => print("The job is waiting to be processed."),
  JobStatus.Complete => print("The job finished successfully."),
  JobStatus.Failed => print("The job failed to complete.")
}
```

By using an enum, you leverage the Boba compiler as a safety net. It becomes impossible for a `JobStatus` variable to ever hold an invalid value like "in-progress" or "error". This eliminates an entire category of bugs at compile time.

This chapter provides a foundation for creating your own types. In the next chapter, you'll learn about `structs`, which let you group related data together.

================================================================================

# Bobalings Exercises for Chapter 08

--- Exercise: exercises/08_enums/enums1.boba ---

//! An enum is a custom type that can be one of several variants.
//! It's useful for modeling state that can only be one of a fixed set
//! of possibilities. For example, the status of a network request
//! could be `Pending`, `Success`, or `Failed`.
//!
//! Your task is to complete the enum definition and use one of its variants.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

// 1. Complete the `Direction` enum by adding variants for
//    North, South, East, and West.
enum Direction {
    // Add variants here
}

fn main() {
    // 2. The player is starting to move. Create a variable named `player_direction`
    //    and assign it the `South` variant of your `Direction` enum.
    let player_direction = // Assign the Southvariant of theDirection enum here.

    // This function will print the direction. You don't need to change it.
    print_direction(player_direction);
}


/// This function is already complete. You don't need to change it.
/// It takes a `Direction` and prints a message.
/// We'll learn how `match` works in the next exercise!
fn print_direction(direction: Direction) {
    let direction_text = match direction {
        Direction.North => "North",
        Direction.South => "South",
        Direction.East => "East",
        Direction.West => "West",
    };
    print(f"Player is moving {direction_text}!");
}

// When you've fixed the code, running the exercise should produce the output:
// "Player is moving South!" 

--- Exercise: exercises/08_enums/enums2.boba ---

//! The `match` statement is a powerful control flow tool in Boba.
//! It allows you to compare a value against a series of patterns and
//! execute code based on which pattern matches.
//!
//! A key feature of `match` is that it must be exhaustive. This means
//! you must provide a branch for every possible variant of an enum.
//! The compiler guarantees this, preventing bugs from unhandled cases.
//!
//! Your task is to complete the `match` statement to handle all
//! variants of the `LogLevel` enum.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

enum LogLevel {
    Info,
    Warning,
    Error,
}

/// This function maps a `LogLevel` to a decorative string.
fn get_log_prefix(level: LogLevel) -> string {
    // The `match` statement below is not exhaustive.
    // 1. Add a branch for the `LogLevel.Warning` variant.
    //    It should return the string "[WARNING]: ".
    //
    // 2. Add a branch for the `LogLevel.Error` variant.
    //    It should return the string "[ERROR]: ".
    //
    // Hint: The compiler will guide you! It will tell you exactly
    // which patterns are missing.
    let prefix = match level {
        LogLevel.Info => "[INFO]: ",
        // Add the other two branches here
    };
    return prefix;
}

fn main() {
    let info_prefix = get_log_prefix(LogLevel.Info);
    print(f"{info_prefix}This is an informational message.");

    let warning_prefix = get_log_prefix(LogLevel.Warning);
    print(f"{warning_prefix}This is a warning.");

    let error_prefix = get_log_prefix(LogLevel.Error);
    print(f"{error_prefix}This is an error!");
}

// After you've fixed the `get_log_prefix` function, running the exercise
// should produce the following output:
//
// [INFO]: This is an informational message.
// [WARNING]: This is a warning.
// [ERROR]: This is an error! 

