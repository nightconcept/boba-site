# Lesson: 13-result-type

In any real-world application, things can go wrong. A file might not exist, a network request might fail, or user input might be invalid. While other languages often rely on exceptions and `try...catch` blocks to handle these situations, Boba encourages a more explicit approach using the `Result` enum. The benefit of this approach is that using `Result` makes a function's potential for failure an honest part of its type signature, forcing the caller to acknowledge and handle potential errors at compile time.

## The `Result` Enum

The `Result` enum is a powerful tool for handling operations that can either succeed or fail.

```boba
enum Result<T, E> {
  Ok(T),    // The 'Success' variant, holds a value of type T
  Err(E)    // The 'Failure' variant, holds a value of type E
}
```

- `T` is a generic placeholder for the type of data you expect on success.
- `E` is a generic placeholder for the type of error you expect on failure.

## The `?` Operator

Boba provides the `?` operator as a convenient way to work with `Result` values. It simplifies error handling by propagating errors up the call stack.

This operator is powerful syntactic sugar for a `match` statement that handles the `Err` case for you. Here's how it works:

- If the `Result` is `Ok(value)`, the `?` operator unwraps the `Result` and gives you the `value` inside.
- If the `Result` is `Err(error)`, the `?` operator immediately stops the current function and returns the `Err(error)`.

Before the `?` operator was introduced, handling nested `Result` values required explicit `match` statements. For example, to get a value from a fallible operation and continue, you would write:

```boba
fn do_something() -> Result<string, error> {
    let result = might_fail() // This returns a Result

    let value = match result {
        Ok(v) => v, // Extract the value and continue
        Err(e) => return Err(e), // On failure, return immediately
    }

    // ... continue working with `value`
    return Ok(f"Success with {value}")
}
```

The `?` operator is a concise shorthand for that entire `match` block.

// A simple struct to hold our error information.
```boba
struct Error {
  message: string,
}
```

// A struct to hold our configuration data
```boba
struct Config {
  hostname: string,
  port: int,
  enable_https: boolean
}
```

The true power of the `?` operator becomes apparent when chaining multiple operations that can each fail, as it allows you to write a clean "happy path" while correctly propagating any error that occurs at any step.

The following function, `load_config`, is a great example of this. It will read a file and parse it as JSON. Both of these operations can fail, making them perfect candidates for using `Result` and the `?` operator.

```boba
fn load_config() -> Result<Config, Error> {
    // Assume `read_file` and `parse_json` are fallible functions
    // provided by Boba's standard library, imported from modules
    // like `boba::fs` and `boba::json`.
    var content = read_file("config.json")?
    var config = parse_json(content)?

    print("Config loaded!")

    return Ok(config)
}
```

### Time to Practice!

Now it's your turn. Look for opportunities in your own code to refactor functions to return a `Result`. Use the `?` operator to clean up your error handling and make your code more robust and readable.

================================================================================

# Bobalings Exercises for Chapter 13

--- Exercise: exercises/13_error_handling_result/result1.boba ---

//! When a function you're calling returns a `Result`, you often want to
//! propagate the error up to the function that called yours. The `?`
//! operator is a clean, idiomatic way to do this.
//!
//! If the `Result` is `Ok(value)`, `?` unwraps it and gives you the `value`.
//! If the `Result` is `Err(error)`, `?` immediately returns the `Err` from
//! the current function.
//!
//! Your task is to use the `?` operator to propagate an error.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn might_fail() -> Result<string, string> {
  // For this exercise, we'll just simulate a failure.
  return Err("Something went wrong!");
}

fn process() -> Result<string, string> {
  // `might_fail()` returns a Result.
  // Add the `?` operator to the end of the call to propagate the error.
  // The line should be: `let data = might_fail()?;`
  let data = might_fail();

  return Ok("Processed: " + data);
}

fn main() {
  match process() {
    Ok(result) => print(result),
    Err(e) => print(f"Error: {e}"),
  }
}

--- Exercise: exercises/13_error_handling_result/result2.boba ---

//! While the `?` operator is great for propagating errors, sometimes you
//! need to handle an error immediately. For this, you can use a `match`
|! statement on the `Result`.
//!
//! This gives you full control to handle the `Ok` and `Err` cases in
//! different ways.
//!
//! Your task is to use a `match` statement to handle a `Result`.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn parse_number(s: string) -> Result<int, string> {
  // This is a simplified parser for the exercise.
  if s == "123" {
    return Ok(123);
  }
  return Err("Could not parse string");
}

fn main() {
  let result = parse_number("abc");

  // Use a `match` statement to handle the `result`.
  // If it's `Ok(number)`, print the number.
  // If it's `Err(message)`, print the error message.
  /* your code here */
}

--- Exercise: exercises/13_error_handling_result/result3.boba ---

//! If a function can fail in a recoverable way, it should return a
//! `Result<T, E>` to make that possibility explicit in the type system.
//!
//! Your task is to refactor the `safe_divide` function to return a `Result`.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

// This function can fail if the denominator is zero.
//
// 1. Change the function's return type to `Result<float, string>`.
// 2. If `b` is 0, return an `Err` with the message "Division by zero".
// 3. Otherwise, return the result of the division wrapped in `Ok()`.
fn safe_divide(a: float, b: float) -> float {
  return a / b;
}

fn main() {
  let result1 = safe_divide(10.0, 2.0); // Should be Ok(5.0)
  let result2 = safe_divide(10.0, 0.0); // Should be Err(...)

  match result2 {
    Ok(value) => print(f"Result: {value}"),
    Err(e) => print(f"Correctly handled error: {e}"),
  }
}

