# Lesson: 02-variables-and-immutability

In Boba, you can store data in variables. A core principle of the language is **immutability by default**, which helps you write safer, more predictable code.

### `let`: Immutable Bindings

The `let` keyword declares an **immutable binding**. Once a value is assigned, it cannot be changed. This should be your default choice for everything, as it prevents accidental modification. This design choice helps prevent a large class of common bugs where data is changed unintentionally. It makes code easier to reason about because you know a value won't change unexpectedly.

```boba
let message = "Hello, Boba!"
message = "Hello, Dave!" // This will cause a compile error!
```

### Your First Compiler Error: A Helpful Guide

When you try to run the code above, the Boba compiler will stop and show you an error. It might look something like this:

```boba
Error: Cannot assign twice to immutable binding `message`.
  --> hello.boba:2:1
  |
1 | let message = "Hello, Boba!"
  |     ------- help: `message` is declared immutable here.
2 | message = "Hello, Dave!"
  | ^^^^^^^ cannot assign to `message`
  |
  = help: To make this binding mutable, use `var` instead of `let`.
```

This is a key part of the Boba development experience. The compiler is your pair programmer. It doesn't just point out errors; it often tells you exactly how to fix them. Learning to read these messages is a superpower.

### Shadowing: A Safer Way to Transform

As the compiler's help message suggests, you could change let to var to make the variable mutable. But what if you don't really need the variable to change its value over time? What if you just want to perform a transformation and then continue using that name? For this, Boba provides a safer feature called shadowing.

Shadowing allows you to declare a new variable with the same name as a previous one. This new variable "shadows" the old one, meaning the original variable is no longer accessible from this point forward. This is not a mutation; it's creating a brand new, immutable variable.

```boba
let x = 5
let x = x + 1 // This is not mutation!
// This is a new `let` binding that shadows the old `x`.
let x = x * 2
print(f"The final value of x is {x}") // Outputs: The final value of x is 12
```

Shadowing is extremely useful because it allows you to reuse a simple name for a value that you are transforming in a series of steps, all without ever making your data mutable.

> **A Note for JavaScript/TypeScript Developers**
>
> In Boba, `let` creates a binding that cannot be reassigned, similar to `const` in JavaScript. This is different from JavaScript's `let`, which creates a mutable variable. For mutable variables in Boba, you must use `var`.

### `var`: Mutable Variables

You should only use the `var` keyword when you have a specific and necessary reason to change a value after it's been created. You should use `var` only when you explicitly need to track a state that changes over time, such as a counter in a loop, a user's accumulating score, or a value that is built up incrementally.

```boba
// A mutable variable, used only when mutation is required.
var counter = 0
counter = counter + 1 // This is allowed.
```

By defaulting to `let` for everything, you make your code's intent clearer and safer.

### Core Data Types

Now that you know how to declare variables with `let` and `var`, let's explore the fundamental types of data they can hold. Boba has a set of primitive types that are the building blocks of data in your programs. When you want to be explicit, you can add a type annotation after the variable name using a colon, like this: `let name: type = value`.

### `int`

The `int` type is used to represent a 64-bit signed integer (a whole number). It is the ideal type for counting, indexing into collections, representing IDs, and any situation where fractional values are not needed.
```boba
let score: int = 100
let current_level = 10 // Inferred as int
```

### `float`

The `float` type is used for 64-bit floating-point numbers (numbers with a decimal point). It's essential for any calculations involving fractional values, such as financial data, measurements, or scientific computations.

```boba
let price: float = 4.99
let temperature = -15.5 // Inferred as float
```

### `string`

The `string` type is used to represent text.

```boba
let message: string = "Hello, Boba!"
var player_name = "June" // Inferred as a string
```

#### Formatting Strings

To embed variables and expressions directly into a string, Boba uses **f-strings**. An f-string is a string literal prefixed with the letter `f`. This prefix acts as a signal that commands the compiler to actively scan the string for `{}` placeholders and evaluate the expressions inside them.

```boba
let player_name = "Ada"
let level: int = 10

// Use an f-string to create a formatted message.
let welcome_message = f"Welcome, {player_name} (Level {level})!" 
print(welcome_message) // Outputs: Welcome, Ada (Level 10)!

// Regular strings do not process the braces.
let template = "This is a template: {some_value}"
print(template) // Outputs: This is a template: {some_value}
```

### `boolean`

The `boolean` type represents a value that can be either `true` or `false`. Booleans are essential for controlling the flow of your program.

```boba
var is_game_over: boolean = false
var has_key = true // Inferred as a boolean
```

### Type Inference: Letting Boba Do the Work

In the examples, you may have noticed that sometimes we declare a type (`let score: int = 100`) and sometimes we don't (`let current_level = 10`). When you assign a value as you declare a variable, Boba can usually figure out, or infer, the type for you. `10` is clearly an `int`, `"Ada"` is a `string`, and `true` is a `boolean`. While this makes code more concise, adding explicit type annotations can serve as powerful documentation, especially on function signatures or for complex data. It's a choice the developer makes to balance conciseness with clarity for other developers (or their future self).

#### **Time to Practice!**
>
> Head over to your next set of exercises. You'll get hands-on practice creating variables, fixing compiler errors related to immutability, and working with `string`, `int`, and `boolean` types.

================================================================================

# Bobalings Exercises for Chapter 02

--- Exercise: exercises/02_variables/primitives1.boba ---

//! Boba is a statically-typed language, which means the type of every
//! variable is known at compile time. This helps prevent a whole class of bugs.
//!
//! If you declare a variable with a specific type, you can only assign
//! values of that type to it.
//!
//! Your task is to fix the type mismatch in the code below.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn main() {
  // The variable `score` is explicitly typed as an `int`.
  // However, it is being assigned a `string` value.
  // Change the value to an integer (e.g., 100) to fix the error.
  let score: int = "a string value";

  print(f"The score is: {score}");
}

--- Exercise: exercises/02_variables/primitives2.boba ---

//! Boba uses f-strings to embed expressions inside string literals.
//! A regular string will print the literal characters, including braces.
//! An f-string, which starts with `f"..."`, will evaluate the expressions
//! inside the `{}`.
//!
//! Your task is to turn a regular string into an f-string.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn main() {
  let player_name = "Ada";

  // The string below is a regular string, so it will print the literal
  // text "{player_name}".
  // Add the `f` prefix to the string to make it an f-string and correctly
  // print the player's name.
  let welcome_message = "Welcome, {player_name}!";

  print(welcome_message);
}

--- Exercise: exercises/02_variables/primitives3.boba ---

//! Long numbers can be hard to read. Boba allows you to use an underscore `_`
//! as a visual separator inside number literals. The compiler completely
//! ignores it, but it can make your code much more readable.
//!
//! This works for both `int` and `float` types.
//!
//! Your task is to make the number below easier to read.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn main() {
  // The number below is one billion. It's hard to read at a glance.
  // Add underscores as thousands separators to improve readability.
  // For example: `1_000_000_000`
  let population = 1000000000;

  print(f"The population is: {population}");
}

--- Exercise: exercises/02_variables/variables1.boba ---

//! In Boba, you must declare a variable before you can use it.
//! The `let` keyword creates an immutable binding.
//!
//! The compiler will tell you when it can't find a variable in the
//! current scope.
//!
//! Your task is to declare a variable to fix the error.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn main() {
  // The variable `x` is used here, but it has not been declared.
  // Declare it using `let` on the line above the print statement.
  // For example: `let x = 5`
  print(f"The value of x is {x}");
}

--- Exercise: exercises/02_variables/variables2.boba ---

//! Boba's variables are immutable by default.
//! This means that once a value is bound to a variable with `let`,
//! it cannot be changed. This is a safety feature to prevent bugs.
//!
//! The compiler will prevent you from reassigning an immutable variable.
//!
//! Your task is to fix the error by preventing the reassignment.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn main() {
  let x = 5;
  print(f"The number is {x}");

  // The line below tries to reassign the immutable variable `x`.
  // This is not allowed!
  // Comment out the line to fix the error.
  x = 10;

  print(f"The number is now {x}");
}

--- Exercise: exercises/02_variables/variables3.boba ---

//! While Boba defaults to immutable variables, sometimes you need a
//! variable that can be changed. For this, you use the `var` keyword.
//!
//! Use `var` when you have a clear reason to mutate a variable's value.
//!
//! Your task is to make the variable `x` mutable to allow reassignment.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn main() {
  // The variable `x` is declared with `let`, making it immutable.
  // Change `let` to `var` to make it mutable and allow the reassignment below.
  let x = 5;
  print(f"The number is {x}");

  x = 10; // This reassignment will now be allowed.

  print(f"The number is now {x}");
}

--- Exercise: exercises/02_variables/variables4.boba ---

//! Boba allows you to "shadow" a variable by declaring a new variable
//! with the same name. This is different from mutation. Shadowing creates
//! a brand new variable, and the old one is no longer accessible in this scope.
//!
//! This is useful for transformations. You can have a variable `x`,
//! perform an operation on it, and then bind the result to a new `x`.
//!
//! Your task is to use shadowing to make the code compile.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn main() {
  let x = 5;
  print(f"The number is {x}");

  // The line below is trying to assign a new value to `x`.
  // Instead of mutating, we can shadow the original `x`.
  // Add the `let` keyword to the beginning of the line to create a new
  // variable `x` that shadows the old one.
  x = x + 5;

  print(f"The number is now {x}");
}

