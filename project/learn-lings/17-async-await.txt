# Lesson: 17-async-await

Asynchronous programming is essential for building responsive and efficient applications, especially when dealing with tasks like network requests or file I/O that can take time. Boba makes writing asynchronous, non-blocking code as easy and readable as traditional, synchronous code.

## The `async` and `await` Keywords

Boba's concurrency model is built around two keywords: `async` and `await`.

-   **`async`**: A keyword that modifies a function declaration (`async fn ...`). An `async` function does not block when called. Its return type is implicitly wrapped in a `Future<T>`. A **`Future`** is a placeholder object that represents a computation that hasn't finished yet. It's a promise that a value of type `T` will be available at some point in the future.
-   **`await`**: An operator that can only be used inside an `async` function. It pauses the execution of the async function until the `Future` it is waiting on has completed.

## A Simple Async Example

To understand the core mechanic of `async`/`await`, let's look at a complete example that doesn't involve errors. We'll simulate a network request that takes some time to complete.

```boba
// This async function simulates fetching data from a server.
// It returns a Future that will resolve to a string.
async fn fetch_greeting() -> string {
  // In a real app, this would be a network call.
  // Here, we'll just pretend it takes a moment.
  sleep(1000) // Pauses for 1000 milliseconds
  return "Hello from the server!"
}

// The main entry point of our program must also be async
// so that we can use the `await` keyword inside it.
async fn main() {
  print("Requesting greeting...")
  // We `await` the result of the async function.
  // Our program pauses here until fetch_greeting() is done.
  let greeting = await fetch_greeting()
  print(f"Received: {greeting}")
}
```

When you run this, you'll see "Requesting greeting...", a one-second pause, and then "Received: Hello from the server!". This shows the fundamental flow: calling an `async` function gives you a future, and `await`ing it pauses your current function to get the result.

> **What is an Async Runtime?**
>
> You might be wondering what is actually scheduling and running these `async` functions. Boba includes a built-in **async runtime**. This is a part of the language's standard library that manages a pool of threads and knows how to efficiently run thousands of `async` tasks, pausing them when they are waiting (like for our `sleep` or a real network call) and resuming them when they are ready to make progress. You don't need to configure or manage it; you can just write `async` code and Boba handles the rest.

## The Power of Composition: `await` with `?`

Now that you understand the basics of `async` and `await`, we can combine this knowledge with what you learned about error handling. Things get really powerful when an `async` function can also fail, returning a `Result`. Boba lets you compose `await` and the `?` operator to handle both asynchrony and errors in a single, clean expression.

```boba
// This async function can fail, so it returns a Result.
async fn fetch_user(id: int) -> Result<User, error> { /* ... */ }

// Note the `?` after await!
let user = await fetch_user(user_id: user_id)?
```
This one line does two things in a specific order. First, the `await` keyword acts, pausing the function until the `Future<Result<...>>` is resolved into a plain `Result<...>` value. Only then does the `?` operator inspect that `Result`:

- If the result is an `Err`, the `?` operator propagates it immediately.
- If it's `Ok`, it unwraps the `User` value and assigns it to the variable.

This elegant composition is key to writing robust, readable asynchronous Boba code.

### Time to Practice!

You're ready to tackle asynchronous tasks. The next exercises will prompt you to convert synchronous functions to be `async` and to use `await` to retrieve their results, preparing you for real-world I/O tasks.

================================================================================

# Bobalings Exercises for Chapter 17

--- Exercise: exercises/17_concurrency/async1.boba ---

//! An `async` function does not block. When you call it, it immediately
//! returns a `Future` that will complete at a later time.
//!
//! To get the value from the `Future`, you must `await` it. This pauses
//! the current function until the `Future` is complete.
//!
//! Your task is to `await` the result of the `async` function.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

async fn fetch_data() -> string {
  // In a real app, this would do a network request.
  // Here, we just simulate a delay.
  timer.sleep(ms: 100);
  return "Here is the data!";
}

async fn main() {
  // `fetch_data` is called without `await`. This means `data` will be a
  // `Future<string>`, not a `string`, which will cause a type error.
  // Add the `await` keyword before the function call.
  let data = fetch_data();

  print(f"Received: {data}");
}

--- Exercise: exercises/17_concurrency/async2.boba ---

//! The `await` keyword can only be used inside a function that is marked
//! with the `async` keyword. This is a language rule that ensures the
//! compiler knows how to handle the function's execution.
//!
//! Your task is to mark the `main` function as `async`.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

async fn get_message() -> string {
  return "Hello from an async function!";
}

// This function uses `await`, but it's not marked as `async`.
// The compiler will give you an error.
// Add the `async` keyword before `fn` to fix it.
fn main() {
  let message = await get_message();
  print(message);
}

--- Exercise: exercises/17_concurrency/async3.boba ---

//! `async` functions can also fail, in which case they return a `Result`.
//! This means the full return type is `Future<Result<T, E>>`.
//!
//! Boba allows you to elegantly handle this by composing the `await`
//! keyword and the `?` operator. The expression `await my_func()?` does
//! two things:
//! 1. `await`s the `Future` to complete.
//! 2. If the result is `Ok`, it unwraps the value. If it's `Err`, the `?`
//!    operator propagates the error.
//!
//! Your task is to correctly compose `await` and `?`.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

async fn fetch_user(id: int) -> Result<string, string> {
    if id == 1 {
        return Ok("Alice");
    }
    return Err("User not found");
}

// The main function can succeed without returning a value, so its
// success type is `void`.
async fn main() -> Result<void, string> {
    // The code to be refactored remains the same.
    let user_result = await fetch_user(1);
    let user = match user_result {
        Ok(u) => u,
        Err(e) => return Err(e),
    };

    print(f"Found user: {user}");

    // To return a successful but empty Result, we return Ok(void).
    return Ok(void);
}

