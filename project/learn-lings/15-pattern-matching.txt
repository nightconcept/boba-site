# Lesson: 15-pattern-matching

Boba's primary tool for control flow is the powerful `match` statement. It allows you to check a value against a series of patterns in a clean and expressive way. Its key strength is that the compiler enforces **exhaustiveness**, which is why it is the perfect tool for safely working with enum types like `Option` and `Result`.

### The Rule of Exhaustiveness

A `match` statement in Boba must be **exhaustive**. This means you must provide a branch for every possible value the type can have. The Boba compiler will give you an error if you forget a case, preventing a whole class of bugs.

The `match` statement is most powerful when used with types that have a fixed number of variations, like `Option` and `Result`.

```boba
// Safely unwrapping an Option
match find_user(1) {
    Some(name) => print("Found user: {name}"),
    None => print("User not found.")
}
```

`match` works just as effectively on the `Result` type. Here's how you can handle a function that might return an error:

```boba
fn read_config_file() -> Result<string, error> {
    // This function might return Ok("file content") or Err({message: "..."})
    // ...
}

match read_config_file() {
    Ok(content) => print("Config file content: {content}"),
    Err(err) => print("Failed to read config: {err.message}")
}
```

While `_` is necessary for matching on types with a near-infinite number of values (like `int` or `string`), it should be used cautiously with enums. Using it can sometimes bypass the compiler's exhaustiveness check. For example, if a new variant is added to an enum later, the wildcard `_` will catch it silently instead of causing a helpful compile error that would force you to handle the new case explicitly.

This exhaustiveness is what makes `match` so safe and powerful. It's important to understand this is not just a convention; it's a guarantee. If you were to write a `match` statement for an `Option` and forget to handle the `None` case, your code would not compile. The compiler guarantees that you have considered both the `Some` and `None` cases, or the `Ok` and `Err` cases, before your program can run.

### The Default Case: `_`

Sometimes, you don't want to handle every single case explicitly. For these situations, you can use the wildcard pattern, a single underscore (`_`), as a default or "catch-all" branch. The `_` will match any value that hasn't been matched by the preceding branches.

This is useful when matching on types with many possibilities, like numbers or strings.

```boba
var status_code: int = 418

match status_code {
    200 => print("OK"),
    404 => print("Not Found"),
    // The `_` handles every other possible integer value.
    _ => print("An unexpected error occurred.")
}
```

> #### **Time to Practice!**
>
> The final set of exercises will challenge you to solve problems by writing `match` statements that handle both `Option` and `Result` types, reinforcing the learning from the last three chapters.

================================================================================

# Bobalings Exercises for Chapter 15

--- Exercise: exercises/15_pattern_matching/match1.boba ---

//! The `match` statement in Boba must be **exhaustive**. This means you
//! must provide a branch for every possible value the type can have.
//! This is a powerful safety feature that prevents bugs.
//!
//! The compiler will give you an error if you forget a case.
//!
//! Your task is to fix the non-exhaustive `match` statement.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

enum TrafficLight {
  RED,
  YELLOW,
  GREEN,
}

fn main() {
  let light = TrafficLight.GREEN;

  // This `match` statement is missing the `GREEN` case.
  // The compiler will tell you that the match is not exhaustive.
  // Add a branch for `TrafficLight.GREEN` to fix the error.
  match light {
    TrafficLight.RED => print("Stop!"),
    TrafficLight.YELLOW => print("Caution!"),
  }
}

--- Exercise: exercises/15_pattern_matching/match2.boba ---

//! When you don't want to handle every single case in a `match` statement
//! explicitly, you can use the wildcard pattern, a single underscore `_`.
//!
//! The `_` acts as a default or "catch-all" branch. It will match any
//! value that hasn't been matched by the preceding branches.
//!
//! Your task is to add a wildcard arm to the `match` statement.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn main() {
  let status_code = 418;

  // This `match` statement needs to handle any possible integer value.
  // Add a wildcard arm `_ => print("An unexpected error occurred.")`
  // to handle all other status codes.
  match status_code {
    200 => print("OK"),
    404 => print("Not Found"),
  }
}

--- Exercise: exercises/15_pattern_matching/match3.boba ---

//! A powerful feature of `match` is that you can bind the value inside
//! a pattern to a new variable.
//!
//! For example, in `Some(name) => ...`, the `name` variable will hold the
//! value that is inside the `Some`.
//!
//! Your task is to use the value bound from the `match` pattern.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn main() {
  let user_option: Option<string> = Some("Boba");

  match user_option {
    Some(name) => {
      // The `name` variable is bound to the value "Boba".
      // Use the `name` variable in the print statement below.
      print("Found user: ");
    },
    None => print("User not found."),
  }
}

--- Exercise: exercises/15_pattern_matching/match4.boba ---

//! You can add a conditional guard to a `match` arm using the `where`
//! keyword. This allows you to add more complex conditions to your patterns.
//!
//! The syntax is: `pattern where condition => ...`
//!
//! Your task is to add a `where` clause to a `match` arm.
//!
//! When you are done, remove the `I AM NOT DONE` line below to move on.

// I AM NOT DONE

fn main() {
  let result: Result<int, string> = Ok(150);

  match result {
    // This arm should only match if the number `n` is greater than 100.
    // Add a `where` clause to the pattern: `Ok(n) where n > 100`.
    Ok(n) => print("Received a big number: {n}"),
    Ok(n) => print("Received a smaller number: {n}"),
    Err(msg) => print("An error occurred: {msg}"),
  }
}

