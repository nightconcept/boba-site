---
title: "Defer & Panic"
description: "Learn how to ensure resource cleanup with `defer` and handle unrecoverable errors with `panic`."
---

## Guaranteed Cleanup with `defer`

The `defer` statement schedules a function call to be executed right before the current function exits, regardless of how the function exits. Whether it returns normally, propagates an error with `?`, or exits due to a panic, deferred functions always run.

This makes `defer` perfect for resource cleanup - you can guarantee that files are closed, connections are released, or locks are freed, preventing resource leaks:

// Assume `fs` is Boba's file system module, providing functions
// that return a Result, like `fs.open(path)`.
// We also assume a defined `Error` struct (from the Result chapter).

```boba
pub fn process_file(path: string) -> Result<string, Error> {
    // 1. Open the file. If this fails, we exit, no cleanup needed.
    var file = fs.open(path)?

    // 2. Defer the close call *immediately* after opening.
    // This is now GUARANTEED to run when process_file exits.
    defer file.close()

    // 3. Now, we can focus on the logic without worrying about cleanup.
    var data = file.read_all()?
    if data.is_empty() {
        // We can just return. `defer file.close()` will run automatically.
        return Err({ message: "File is empty" })
    }

    // `defer file.close()` will also run automatically before this return.
    return Ok("Processed data!")
}
```

## Defer Execution Order

If a function has multiple `defer` statements, they execute in **Last-In, First-Out (LIFO)** order. The last `defer` scheduled is the first one to run when the function exits. This ordering is crucial for correct resource management when multiple resources are acquired - resources are cleaned up in reverse order of acquisition.

## Unrecoverable Errors with `panic`

`panic` is reserved for unrecoverable errors that signify bugs in the program's logic. A panic abruptly stops normal execution and should never be used for ordinary, expected errors like missing files or invalid user input - those cases require `Result`.

When a panic occurs, the program begins to **unwind the stack**, executing any `defer` statements it finds along the way. This ensures cleanup code runs even during catastrophic failures:

You can trigger a panic manually with the built-in `panic()` function.

```boba
fn get_guild_rank(player: Player) -> string {
  // This function assumes the player is in a guild.
  let rank_option = player.guild_rank() // Returns Option<string>

  match rank_option {
    Some(rank) => return rank,
    None => {
      // If we get here, it means another part of our code called this
      // function with a player who wasn't in a guild. This is a bug.
      panic(f"Critical error: get_guild_rank called on non-guild member {player.name}!")
    }
  }
}

## When to Use Panic vs Result

**Use `panic`** for programming errors and invariant violations - situations that should never happen if your code is correct. **Use `Result`** for expected failures that are part of normal program operation.

Panic represents "this should be impossible" while Result represents "this might not work."

## Time to Practice!

Experiment with defer and panic to understand resource management:

1. **Use defer for cleanup**: Practice ensuring resources are always released
2. **Try multiple defers**: Understand LIFO execution order
3. **Handle resource chains**: Use defer with nested resource acquisition
4. **Understand panic scenarios**: Identify when panic is appropriate vs Result
5. **Test cleanup behavior**: Verify defer runs during different exit conditions

## What's Next

You now understand how to guarantee resource cleanup with `defer` and handle truly exceptional situations with `panic`. These tools help you write robust programs that clean up properly even when things go wrong. Next, you'll learn about async/await, which enables concurrent programming and helps you write efficient programs that can handle multiple tasks simultaneously.