---
title: "Collections"
description: "Learn about Boba's primary collection types: lists, maps, and tuples."
---

Collections let you work with multiple related values efficiently. Boba provides familiar collection types with some modern improvements for safety and expressiveness.

## Lists: Ordered Collections

Lists are Boba's primary data structure for storing multiple values of the same type in a specific order. Boba lists are dynamic, meaning they can grow and shrink during program execution. This flexibility makes them perfect for scenarios where you don't know the exact number of items ahead of time, such as collecting user input, processing file contents, or building results from calculations.

The key advantage of lists is type safety - Boba ensures all elements are the same type, preventing runtime errors like trying to perform mathematical operations on mixed data types:

```boba
// Creating lists
let scores = [100, 95, 80, 92]
var shopping_list = ["eggs", "milk", "bread"]

// Lists with explicit types (when inference isn't clear)
let user_ids: List<int> = []
var names: List<string> = ["Alice", "Bob"]
```

### Basic List Operations

Boba provides intuitive methods for working with lists. The `len()` method returns the number of elements, `push()` adds items to the end, and indexing with `[]` lets you access specific positions. Boba's type system ensures these operations are safe at compile time.

One important design choice in Boba is that list access returns `Option` types for safety, preventing index-out-of-bounds crashes that can occur when accessing invalid positions:

```boba
let mut numbers = [1, 2, 3]

// Accessing elements (zero-indexed)
print(numbers[0])        // 1
print(numbers.len())     // 3

// Adding elements
numbers.push(4)          // [1, 2, 3, 4]

// Checking contents
let has_two = numbers.contains(2)    // true
let first = numbers.first()          // Some(1)
let last = numbers.last()            // Some(4)
```

### Functional List Operations

Functional programming methods transform lists without modifying the original data, following Boba's immutability principles. These methods take closures (anonymous functions) as arguments, allowing you to specify exactly how each element should be processed.

The `filter()` method creates a new list containing only elements that meet your criteria, while `find()` returns the first matching element wrapped in an `Option`. The `map()` method transforms each element according to your function:

```boba
let scores = [88, 42, 95, 71, 100]

// Filter: create new list with elements that pass a test
let passing = scores.filter(|score| score >= 70)    // [88, 95, 71, 100]

// Find: get first element that matches (returns Option)
let perfect = scores.find(|score| score == 100)     // Some(100)
let missing = scores.find(|score| score == 50)      // None

// Map: transform each element (covered more in later chapters)
let curved = scores.map(|score| score + 5)          // [93, 47, 100, 76, 105]
```

### List Slicing

Slicing lets you extract portions of lists without writing loops or managing indices manually. Boba's range syntax (`..` for exclusive, `..=` for inclusive) makes this operation both clean and safe.

When you slice a list, you're creating a new list containing only the elements within the specified range. This feature is particularly useful for data processing tasks like pagination, extracting headers from data files, or implementing sliding window algorithms:

```boba
let data = [10, 20, 30, 40, 50]

// Get elements from index 1 to 3 (exclusive)
let middle = data[1..4]     // [20, 30, 40]

// From start to index
let start = data[..3]       // [10, 20, 30]

// From index to end
let end = data[2..]         // [30, 40, 50]
```

## Maps: Key-Value Collections

Maps associate unique keys with values, enabling fast lookups by key rather than position. This makes them ideal for representing structured data like user profiles, configuration settings, or any scenario where you need to organize information by meaningful identifiers.

Boba's maps prioritize safety: accessing a non-existent key doesn't crash your program. Instead, Boba returns `Option` types that force you to handle the "key not found" case explicitly:

```boba
// Creating maps
let scores = {"alice": 100, "bob": 85, "charlie": 92}
var config: Map<string, bool> = {"debug": true, "cache": false}

// Access and modification
print(scores["alice"])      // 100
scores["david"] = 78        // Add new entry

// Safe access returns Option (prevents KeyError-like crashes)
let alice_score = scores.get("alice")    // Some(100)
let missing = scores.get("eve")          // None

// Map operations
print(scores.len())                      // 4
let has_bob = scores.contains_key("bob") // true
let all_keys = scores.keys()             // ["alice", "bob", "charlie", "david"]
let all_values = scores.values()         // [100, 85, 92, 78]
```

## Tuples: Fixed-Size Mixed Types

Tuples group a small, fixed number of related values that may have different types. Unlike lists, tuples are immutable and their size is determined at creation time. This makes them perfect for representing coordinates, database records, or function return values where you need multiple pieces of related data.

Tuples are useful when the data forms a logical unit - like a point in 2D space `(x, y)` or a person's basic info `(name, age, active_status)`. The compiler knows exactly how many elements exist and their types, enabling better optimization and error checking:

```boba
// Creating tuples
let point = (10, 20)                    // (int, int)
let user = ("Alice", 25, true)          // (string, int, bool)
let empty = ()                          // Empty tuple

// Accessing with dot notation
print(point.0)          // 10
print(user.1)           // 25

// Tuple destructuring
let (x, y) = point
let (name, age, active) = user
print(f"User {name} is {age} years old")
```

### Tuples vs Lists

**Use tuples when:**
- Fixed number of items known at compile time
- Items have different types
- You want to treat the group as a single unit

**Use lists when:**
- Variable number of items
- All items are the same type
- You need to add/remove items dynamically

## Spread Operator

The spread operator (`...`) provides a declarative way to combine collections, meaning you describe what you want rather than writing loops to achieve it. Instead of manually copying elements or writing merge logic, you can express the entire operation directly in the collection literal.

For maps, the spread operator follows a "last writer wins" policy for duplicate keys, making it excellent for configuration patterns where you have default settings that can be overridden:

```boba
// Spreading lists
let first = [1, 2, 3]
let second = [6, 7, 8]
let combined = [...first, 4, 5, ...second]    // [1, 2, 3, 4, 5, 6, 7, 8]

// Spreading maps (right-most wins for duplicate keys)
let defaults = {"theme": "dark", "size": 14}
let overrides = {"size": 16, "sidebar": true}
let config = {...defaults, ...overrides}
// Result: {"theme": "dark", "size": 16, "sidebar": true}
```

## Collection Safety Features

Boba's collection design prioritizes preventing common runtime errors. The immutable-by-default approach means you can't accidentally modify data you didn't intend to change. Safe access methods like `get()` for maps return `Option` types instead of throwing exceptions, forcing you to handle edge cases explicitly.

These safety features shift potential runtime crashes into compile-time errors, making your programs more reliable. While this might seem like extra work initially, it prevents bugs that can occur when collections are accessed unexpectedly:

```boba
// Immutable collections by default
let readonly_list = [1, 2, 3]
// readonly_list.push(4)  // Compile error!

// Safe map access prevents crashes
let scores = {"alice": 100}
// let bob_score = scores["bob"]     // Would panic in some languages
let bob_score = scores.get("bob")   // Returns None safely

// Out-of-bounds access is checked
let items = [1, 2, 3]
// let invalid = items[10]  // Runtime panic with clear error message
```

## Working with Collections

Common patterns you'll use frequently:

```boba
// Building collections incrementally
var results = []
for i in 1..5 {
    results.push(i * i)     // [1, 4, 9, 16]
}

// Checking if collections contain values
let valid_statuses = ["pending", "approved", "rejected"]
let current = "approved"
if current in valid_statuses {
    print("Valid status")
}

// Processing collections
let words = ["hello", "world", "boba"]
for word in words {
    print(f"Word: {word}")
}
```

## Key Differences from Other Languages

**From JavaScript:**
- Maps don't return `undefined` for missing keys, they return `Option`
- Lists/arrays are strongly typed (all elements same type)
- Immutable by default

**From Python:**
- Similar syntax but static typing required
- Map access is safer (no `KeyError` exceptions)
- List methods return new lists instead of modifying in place

**From Java/C#:**
- More concise syntax for creation and manipulation
- Functional methods (filter, map) built-in
- Type inference reduces boilerplate

## Time to Practice!

Experiment with Boba's collections:

1. **Create different collection types**: Lists, maps, and tuples with various data
2. **Try functional operations**: Use `filter()` and `find()` with different conditions
3. **Practice safe access**: Use `get()` for maps and handle `Option` results
4. **Experiment with spread**: Combine lists and maps using the spread operator
5. **Use slicing**: Extract portions of lists with range syntax

## What's Next

You now understand Boba's collection types and their safety features. The `Option` type you saw with map access is a fundamental part of Boba's error handling philosophy. Next, you'll learn about loops and how to iterate over these collections efficiently, including Boba's powerful destructuring capabilities in `for` loops.