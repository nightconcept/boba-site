---
title: "Option"
description: "Learn how Boba's built-in Option<T> type provides a robust and safe way to handle values that might be absent, preventing an entire category of null-related errors."
---

import { Aside } from '@astrojs/starlight/components';

Many programming languages represent the absence of a value with `null`, but this approach can lead to unexpected runtime errors when you forget to check for null values. Boba was designed without `null` to prevent this entire category of errors.

Instead, Boba provides a robust, built-in enum called `Option<T>` to handle values that might be absent. This makes the possibility of absence explicit in the type system, forcing you to handle it safely.

## The `Option<T>` Enum

The `Option<T>` enum represents a value that might or might not exist. By using `Option<T>`, the possibility of an absent value becomes part of the type system:

```boba
enum Option<T> {
    Some(T), // Represents the presence of a value of type T
    None,    // Represents the absence of a value
}
```

-   `Some(T)`: A variant that holds a value of type `T`.
-   `None`: A variant that represents the absence of a value. It is similar to `null` but is type-safe.

The compiler forces you to acknowledge and handle the `None` case, preventing null reference errors before they happen. A common way to handle an `Option` is to use a `match` statement to provide a default value in the `None` case:

```boba
let timeout_option: Option<int> = user_settings.get("timeout")

let timeout: int = match timeout_option {
    Some(value) => value,
    None => 5000, // Default to 5000ms
}
```

## Shortcut: Unwrapping with a Default using ??

The `??` operator provides a clean shorthand for the common pattern of unwrapping a `Some` value or providing a default value if it's `None`. This operator makes your code cleaner by removing the boilerplate of a match statement:

```boba
// If the left side is Some(t), use t. If it's None, use the right side.
let value = config_map.get("timeout") ?? 5000
```


## When to Use Option vs. Result

Both `Option` and `Result` deal with unexpected values, but they serve different purposes. **Use `Option<T>`** when it's normal and expected for a value to be absent - like searching for a user that might not exist, or getting the first element of a potentially empty list.

**Use `Result<T, E>`** when an operation is supposed to succeed but could fail due to external circumstances - like reading a file that might not exist, or parsing malformed JSON. The key difference is whether absence is expected (Option) or represents a failure (Result).

## Safe Operations with Option

String indexing in Boba can panic if you access an out-of-bounds index. This is a perfect example where `Option` provides safety - instead of panicking, functions can return `None` for invalid operations.

## Time to Practice!

Experiment with `Option` to understand safe null handling:

1. **Create optional values**: Write functions that return `Option<T>` for values that might not exist
2. **Use pattern matching**: Practice handling both `Some` and `None` cases with `match`
3. **Try the `??` operator**: Use the shorthand for providing default values
4. **Chain optional operations**: Combine multiple optional values safely
5. **Compare with Result**: Understand when to use `Option` vs `Result`

## What's Next

You now understand how to handle absent values safely using `Option`. This eliminates null pointer exceptions and makes your code more reliable by forcing explicit handling of missing data. Next, you'll learn about pattern matching, a powerful feature that lets you destructure and match against complex data structures beyond just `Option` and `Result`.