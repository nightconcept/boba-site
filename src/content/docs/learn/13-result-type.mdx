---
title: "Result"
description: "Learn how to handle operations that can fail gracefully in Boba using the Result enum and the `?` operator."
---

In real-world applications, things can go wrong. Files might not exist, network requests might fail, or user input might be invalid. Boba encourages explicit error handling using the `Result` enum instead of exceptions.

The benefit of this approach is that `Result` makes a function's potential for failure part of its type signature, forcing callers to acknowledge and handle potential errors at compile time. This prevents forgotten error handling that can cause crashes.

## The `Result` Enum

The `Result` enum is a powerful tool for handling operations that can either succeed or fail. It forces you to consider both success and failure cases explicitly:



```boba
enum Result<T, E> {
  Ok(T),    // The 'Success' variant, holds a value of type T
  Err(E)    // The 'Failure' variant, holds a value of type E
}
```

- `T` is a generic placeholder for the type of data you expect on success.
- `E` is a generic placeholder for the type of error you expect on failure.

## The `?` Operator

The `?` operator provides a convenient way to work with `Result` values by propagating errors up the call stack. It's syntactic sugar for a `match` statement that handles the `Err` case automatically.

If the `Result` is `Ok(value)`, the `?` operator unwraps and gives you the `value`. If it's `Err(error)`, the operator immediately returns that error from the current function:

Before the `?` operator was introduced, handling nested `Result` values required explicit `match` statements. For example, to get a value from a fallible operation and continue, you would write:

```boba
fn do_something() -> Result<string, error> {
    let result = might_fail() // This returns a Result

    let value = match result {
        Ok(v) => v, // Extract the value and continue
        Err(e) => return Err(e), // On failure, return immediately
    }

    // ... continue working with `value`
    return Ok(f"Success with {value}")
}
```

The `?` operator is a concise shorthand for that entire `match` block.

// A simple struct to hold our error information.
```boba
struct Error {
  message: string,
}
```

// A struct to hold our configuration data
```boba
struct Config {
  hostname: string,
  port: int,
  enable_https: bool
}
```

## Chaining Fallible Operations

The true power of the `?` operator becomes apparent when chaining multiple operations that can each fail. It allows you to write a clean "happy path" while correctly propagating any error.

The following function reads a file and parses it as JSON. Both operations can fail, making them perfect candidates for using `Result` and the `?` operator:

```boba
fn load_config() -> Result<Config, Error> {
    // Assume `read_file` and `parse_json` are fallible functions
    // provided by Boba's standard library, imported from modules
    // like `std:fs` and `std:json`.
    var content = read_file("config.json")?
    var config = parse_json(content)?

    print("Config loaded!")

    return Ok(config)
}
```

## Error Handling Best Practices

**Use Result for fallible operations**: Any function that can fail should return a `Result` rather than panicking. **Chain operations with `?`**: Use the `?` operator to create clean error propagation chains.

**Be specific with error types**: Use meaningful error types that help callers understand what went wrong and how to handle it.

## Time to Practice!

Experiment with `Result` to build robust error handling:

1. **Create fallible functions**: Write functions that return `Result` for operations that might fail
2. **Use the `?` operator**: Practice chaining fallible operations cleanly
3. **Handle both cases**: Use `match` to handle both `Ok` and `Err` cases explicitly
4. **Design error types**: Create meaningful error types for different failure modes
5. **Chain operations**: Combine multiple fallible operations using `?`

## What's Next

You now understand how to handle operations that might fail using `Result`. This explicit error handling makes your programs more reliable by forcing you to consider failure cases. Next, you'll learn about the `Option` type, which handles the common case of values that might not exist, providing a safe alternative to null pointers.