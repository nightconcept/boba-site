---
title: "Variables"
description: "Learn how to store data in variables, why Boba defaults to immutability, and explore core data types."
---

Boba uses immutable variables by default, preventing many common runtime bugs. Here's the syntax:

```boba
// Immutable binding (default)
let score = 100
let name = "Player"

// Mutable variable (when needed)
var counter = 0
counter = counter + 1
```

## Immutable by Default

Unlike most languages, Boba variables are immutable unless explicitly marked mutable:

```boba
let message = "Hello"
message = "Hi"  // Compile error
```

Error output:
```
Error: Cannot assign twice to immutable binding `message`
  --> example.boba:2:1
  |
1 | let message = "Hello"
  |     ------- help: `message` is declared immutable here
2 | message = "Hi"
  | ^^^^^^^ cannot assign to `message`
  |
  = help: To make this binding mutable, use `var` instead of `let`
```

This approach prevents bugs where variables change unexpectedly, making your code more predictable and easier to debug.
## When to Use Mutable Variables

While `let` should be your default choice, `var` is necessary when you need to modify state over time. Here are the most common scenarios:

```boba
// Simple counter
var score = 0
score = score + 10
score = score + 5
print(score)  // 15

// Building strings step by step
var message = "Hello"
message = message + ", "
message = message + "World!"
print(message)  // Hello, World!

// Updating game state
var player_health = 100
player_health = player_health - 25  // Take damage
player_health = player_health + 10  // Healing potion
print(f"Health: {player_health}")   // Health: 85
```

## Basic Data Types

Boba has familiar primitive types with type inference:

```boba
let score = 100              // int (inferred)
let price = 4.99             // float (inferred)  
let name = "Player"          // string (inferred)
let active = true            // bool (inferred)

// Explicit types when needed
let user_id: int = 12345
let balance: float = 0.0
```

### String Interpolation

Boba supports f-string syntax for embedding expressions:

```boba
let player = "Ada"
let level = 10
let message = f"Welcome, {player} (Level {level})!"
print(message)  // Welcome, Ada (Level 10)!
```

### Numeric Literals

Multiple number formats are supported:

```boba
let decimal = 1_000_000      // Underscores for readability
let hex = 0xFF               // Hexadecimal
let binary = 0b1010_0101     // Binary with grouping
let octal = 0o755            // Octal (file permissions)
let scientific = 6.626e-34   // Scientific notation
```

## Type Inference vs Explicit Types

Boba's type inference handles most cases, but explicit types help with clarity:

```boba
// Type inference works well
let score = 100
let name = "Player"
let active = true

// Explicit types for clarity
let user_id: int = 12345
let temperature: float = 98.6
let debug_mode: bool = false
```

## Time to Practice!

Now it's time to experiment with variables and types:

1. **Create immutable variables**: Practice using `let` with different data types
2. **Try mutating immutable variables**: See the compiler error messages in action
3. **Use mutable variables**: Build a simple counter or accumulator with `var`
4. **Experiment with type inference**: Try explicit types vs. letting Boba infer them
5. **Play with f-strings**: Create formatted messages with multiple variables

## What's Next

You now understand Boba's variable system and how immutability by default makes your code safer. Next, you'll learn about functions and discover how Boba's named parameter system prevents argument ordering bugs. This feature makes function calls self-documenting and eliminates an entire class of runtime errors.
