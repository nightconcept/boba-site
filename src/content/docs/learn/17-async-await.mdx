---
title: "Async/Await"
description: "Learn how to write non-blocking, asynchronous code in Boba using `async` and `await`."
---

Asynchronous programming is essential for building responsive and efficient applications, especially when dealing with tasks like network requests or file I/O that can take time. Boba makes writing asynchronous, non-blocking code as easy and readable as synchronous code.

Instead of blocking your entire program while waiting for slow operations, async/await lets you handle multiple tasks concurrently, improving performance and responsiveness.

## The `async` and `await` Keywords

Boba's concurrency model is built around two keywords: `async` and `await`. **`async`** modifies a function declaration, making it non-blocking and wrapping its return type in a `Future<T>` - a placeholder for a computation that hasn't finished yet.

**`await`** can only be used inside async functions. It pauses execution until the `Future` it's waiting on completes, then returns the result. This pause doesn't block other tasks from running.

## A Simple Async Example

To understand the core mechanics of `async`/`await`, let's simulate a network request that takes time to complete. This example shows how async functions pause and resume without blocking other operations:

```boba
// This async function simulates fetching data from a server.
// Assume `sleep` is a built-in function from a `time` module.
async fn fetch_greeting() -> string {
  // In a real app, this would be a network call.
  // Here, we'll just pretend it takes a moment.
  sleep(1000) // Pauses for 1000 milliseconds
  return "Hello from the server!"
}

// The main entry point of our program must also be async
// so that we can use the `await` keyword inside it.
async fn main() {
  print("Requesting greeting...")
  // We `await` the result of the async function.
  // Our program pauses here until fetch_greeting() is done.
  let greeting = await fetch_greeting()
  print(f"Received: {greeting}")
}
```

When you run this, you'll see "Requesting greeting...", a one-second pause, and then "Received: Hello from the server!". This shows the fundamental flow: calling an `async` function gives you a future, and `await`ing it pauses your current function to get the result.

## The Async Runtime

Boba includes a built-in **async runtime** that manages async tasks efficiently. This runtime uses a thread pool to run thousands of async tasks, pausing them when they're waiting (like for network calls) and resuming them when ready.

You don't need to configure or manage the runtime - just write async code and Boba handles the scheduling and execution automatically.

## Composing `await` with `?`

Async functions can also fail, returning a `Result`. Boba lets you compose `await` and the `?` operator to handle both asynchrony and errors in a single, clean expression.

This composition makes error handling in async code as clean as in synchronous code:

```boba
// This async function can fail, so it returns a Result.
// Assume `User` and `error` are structs you have defined elsewhere.
async fn fetch_user(id: int) -> Result<User, error> { /* ... */ }

// Note the `?` after await!
let user = await fetch_user(user_id: user_id)?
```
This one line does two things in order: `await` pauses until the `Future<Result<...>>` resolves, then `?` inspects the result. If it's `Err`, the error propagates immediately. If it's `Ok`, the value is unwrapped and assigned.

This elegant composition is key to writing robust, readable asynchronous code.

## Running Futures Concurrently

While `await` is great for waiting on a single result, the true power of async is running multiple operations simultaneously. Boba provides ways to await multiple futures concurrently.

For example, `Future.all()` takes a list of futures and returns a single future that completes when all inputs have completed:

```boba
async fn get_user_data() -> string {
    // Simulate a slow DB call
    timer.sleep(ms: 100)
    return "User Data"
}

async fn get_app_settings() -> string {
    // Simulate another slow network call
    timer.sleep(ms: 150)
    return "App Settings"
}

async fn main() {
    print("Fetching data concurrently...")
    let results = await Future.all([
        get_user_data(),
        get_app_settings(),
    ])
    // This block only runs after BOTH functions are complete.
    // The total time elapsed will be ~150ms, not 250ms.
    print(f"Results: {results}") // e.g., Results: ["User Data", "App Settings"]
}
```

## Time to Practice!

Experiment with async/await to understand concurrent programming:

1. **Convert sync to async**: Transform blocking functions into async versions
2. **Use await**: Practice waiting for async operations to complete
3. **Combine with error handling**: Use `await` with `?` for robust error handling
4. **Run tasks concurrently**: Use `Future.all()` to run multiple operations simultaneously
5. **Understand timing**: Compare sequential vs concurrent execution times

## What's Next

You now understand how to write non-blocking, concurrent code using async/await. This enables you to build responsive applications that handle multiple tasks efficiently without blocking the main execution thread. Next, you'll learn about idiomatic Boba - the patterns and practices that make your code feel natural and follow community conventions.
```