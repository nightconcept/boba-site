---
title: "Exhaustive Pattern Matching with match"
description: "Learn how Boba's exhaustive 'match' statement guarantees correctness by handling every possible case."
---

## Chapter 7: Exhaustive Pattern Matching with `match`

Boba provides a powerful `match` statement for checking a value against a series of patterns. It is a clean and expressive way to handle multiple distinct cases, and it works hand-in-hand with Boba's type system to guarantee that you've handled every possibility.

### The Rule of Exhaustiveness

A `match` statement in Boba must be **exhaustive**. This means you must provide a branch for every possible value the type can have. The Boba compiler will give you an error if you forget a case, preventing a whole class of bugs.

Let's see this with an `enum`.
```boba
enum TrafficLight {
    RED,
    YELLOW,
    GREEN
}

var light = TrafficLight.RED

// This match is exhaustive, so it will compile.
match light {
    TrafficLight.RED => print("Stop!"),
    TrafficLight.YELLOW => print("Caution!"),
    TrafficLight.GREEN => print("Go!")
}

// If you were to comment out the GREEN case, for example,
// the compiler would produce an error!
```

This exhaustiveness is what makes `match` so safe and powerful, especially when working with the `Option` and `Result` types we'll see later. It guarantees at compile time that you have considered both the `Some` and `None` cases.

### The Default Case: `_`

Sometimes, you don't want to handle every single case explicitly. For these situations, you can use the wildcard pattern, a single underscore (`_`), as a default or "catch-all" branch. The `_` will match any value that hasn't been matched by the preceding branches.

This is useful when matching on types with many possibilities, like numbers or strings.

```boba
var status_code: int = 418

match status_code {
    200 => print("OK"),
    404 => print("Not Found"),
    // The `_` handles every other possible integer value.
    _ => print("An unexpected error occurred.")
}
```

### Advanced Pattern Matching

Boba's `match` statement can do much more than simple value checking. You can bind matched values to new variables and use `where` clauses for complex conditions.

```boba
// Assume we have a function that returns a Result<int, string>
var result = my_api.fetch_data()

match result {
    // Bind the value inside Ok to the variable 'n'
    Ok(n) where n > 100 => print("Received a big number: {n}"),
    Ok(n) => print("Received a smaller number: {n}"),

    // Bind the value inside Err to the variable 'msg'
    Err(msg) => print("An error occurred: {msg}")
}