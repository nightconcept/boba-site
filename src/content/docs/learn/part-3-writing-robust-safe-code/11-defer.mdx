---
title: "Chapter 11: Ensuring Cleanup: The defer Statement"
description: "Learn how to ensure cleanup actions, like closing a file, are always executed using the `defer` statement."
---

Welcome to the next step in your Boba journey! We've seen how to handle potential problems with `Result` and `?`. Now, let's learn how to make sure our program always cleans up after itself, no matter what happens.

## The Problem: Forgetting to Clean Up

Imagine you're working with a file. You need to open it, read some data, and then—most importantly—close it. If you don't close the file, you can cause problems like resource leaks.

This gets tricky when your function has multiple ways to exit.

```boba
pub fn process_file(path: string) -> Result<string, error> {
    var file = fs.open(path)?

    var data = file.read_all()?
    if data.is_empty() {
        file.close() // We have to close it here...
        return Err({ message = "File is empty" })
    }

    file.close() // ...and we have to close it here too.
    return Ok("Processed data!")
}
```

It's easy to forget one of those `file.close()` calls, leading to bugs.

## The Solution: `defer`

Boba provides a simple and powerful keyword to solve this: `defer`.

The `defer` statement schedules a function call to be executed right before the current function exits. It doesn't matter *how* the function exits—whether by a `return`, by reaching the end, or by propagating an error with `?`. For developers coming from other languages, `defer` serves a similar purpose to a `finally` block in a `try...catch...finally` statement, but is often more ergonomic.

Let's rewrite our example using `defer`:

```boba
pub fn process_file(path: string) -> Result<string, error> {
    // 1. Open the file. If this fails, we exit, no cleanup needed.
    var file = fs.open(path)?

    // 2. Defer the close call *immediately* after opening.
    // This is now GUARANTEED to run when process_file exits.
    defer file.close()

    // 3. Now, we can focus on the logic without worrying about cleanup.
    var data = file.read_all()?
    if data.is_empty() {
        // We can just return. `defer file.close()` will run automatically.
        return Err({ message = "File is empty" })
    }

    // `defer file.close()` will also run automatically before this return.
    return Ok("Processed data!")
}
```

By placing `defer file.close()` right after `fs.open(path)?`, we make our code cleaner, safer, and easier to read. The cleanup code is right next to the resource it's cleaning up.

## Multiple defer Statements: LIFO Order

You can have more than one `defer` statement in a function. When the function exits, the deferred calls are executed in Last-In, First-Out (LIFO) order. Think of it as a stack of cleanup tasks—the last one you add is the first one to be performed.
```boba
fn process() {
    print("Start Processing")
    defer print("Cleanup Task 1 (Last to run)")
    defer print("Cleanup Task 2 (First to run)")
    print("Finish Processing")
}

// Calling process() will print:
// Start Processing
// Finish Processing
// Cleanup Task 2 (First to run)
// Cleanup Task 1 (Last to run)
```
This LIFO order is deliberate and very useful. It ensures that resources are de-initialized in the reverse order of their initialization, which is almost always what you want.

## Chapter Summary

- The `defer` statement schedules a function call to be executed just before the current function exits.
- This guarantees that cleanup code (like `file.close()`) runs, regardless of how the function returns (normally, via `return`, or via `?`).
- Place `defer` statements immediately after acquiring a resource to make code safer and more readable.
- Multiple `defer` statements are executed in Last-In, First-Out (LIFO) order.