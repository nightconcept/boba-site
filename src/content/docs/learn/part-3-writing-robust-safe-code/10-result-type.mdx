---
title: "Chapter 10: Handling Recoverable Errors: The Result Type"
description: "Learn how to handle operations that can fail gracefully in Boba using the Result enum and the `?` operator."
---

In any real-world application, things can go wrong. While other languages often rely on exceptions and `try...catch` blocks, Boba encourages a more explicit approach to error handling using the `Result` enum. A file might not exist, a network request might fail, or user input might be invalid. Boba encourages a robust approach to error handling using the `Result` enum.

## The `Result` Enum

The `Result` enum is a powerful tool for handling operations that can either succeed or fail.

```boba
enum Result<T, E> {
  Ok(T),    // The 'Success' variant, holds a value of type T
  Err(E)    // The 'Failure' variant, holds a value of type E
}
```

- `T` is a generic placeholder for the type of data you expect on success.
- `E` is a generic placeholder for the type of error you expect on failure.

What is the `E` or `error` type? It can be anything you want, but it's typically a custom struct that contains detailed information. A good error struct might include a unique code for programmatic checking, and a human-readable message:
```boba
struct FileSystemError {
    code: string, // e.g., "FILE_NOT_FOUND"
    message: string,
}
```
This makes your errors much more powerful than simple strings.

## The `?` Operator

Boba provides the `?` operator as a convenient way to work with `Result` values. It simplifies error handling by propagating errors up the call stack.

This operator is powerful syntactic sugar for a `match` statement that handles the `Err` case for you. Here's how it works:

- If the `Result` is `Ok(value)`, the `?` operator unwraps the `Result` and gives you the `value` inside.
- If the `Result` is `Err(error)`, the `?` operator immediately stops the current function and returns the `Err(error)`.

Let's look at an example:

```boba
// A struct to hold our configuration data
struct Config {
  hostname: string,
  port: int,
  enable_https: boolean
}

fn load_config() -> Result<Config, error> {
    // For this example, we'll assume Boba's standard library provides the `read_file` and `parse_json` functions, both of which can fail and therefore return a `Result`.

    // `read_file` returns a `Result<string, error>`.
    // If it's an `Err`, `?` returns it from `load_config`.
    // If it's `Ok`, `?` gives us the string content.
    var content = read_file("config.json")?

    // `parse_json` returns a `Result<Config, error>`.
    // `?` works the same way here.
    var config = parse_json(content)?

    print("Config loaded!")

    // If everything succeeds, we wrap the `Config` in an `Ok` and return it.
    return Ok(config)
}

## Chapter Summary

- Use the `Result<T, E>` enum for functions that can fail in a recoverable way.
- `Result<T, E>` has two variants: `Ok(T)` for success and `Err(E)` for failure.
- The `?` operator is the idiomatic way to handle `Result` values. It unwraps the value from an `Ok` or returns the `Err` from the current function.
- This model encourages explicit, robust error handling throughout your application.