---
title: "Testing"
description: "Learn how to write effective tests for your Boba code, from simple functions to your private implementation details."
---

Testing ensures your code works correctly and continues working as you make changes. Boba's integrated tooling makes testing a simple, first-class part of the development workflow, without requiring any external libraries.

Boba's testing philosophy emphasizes both unit tests (testing individual functions and modules) and integration tests (testing your public API as external users would experience it).

## What is a Test?

In Boba, a test is simply a function marked with the `#[test]` attribute. The test runner discovers and executes these functions automatically when you run `boba test`.

A test **passes** if the function runs to completion without panicking, and **fails** if the function panics at any point. This simple model makes it easy to understand test outcomes:

Let's look at a complete, minimal example. Here we have a function `add()` and a test for it in the same file. We use the built-in `test.assert_eq()` function to check if the output is what we expect.

```boba
//! A module for performing simple math.

/// Adds two numbers.
pub fn add(a: int, b: int) -> int {
    return a + b
}

#[test]
fn test_addition_works() {
    // This test will fail (and panic) if the result is not equal to 4.
    test.assert_eq(add(2, 2), 4)
}
```

When you run `boba test`, you'll see output like this:

```sh
Running 1 test...
test test_addition_works ... ok

Test results: 1 passed; 0 failed.
```

This is the core testing loop: write a little code, write a test, run `boba test`, and see it pass.

## Assertion Functions

The primary way to check for correctness inside a test is with assertions. The `test` module is built-in and automatically available in any function marked with the `#[test]` attribute.

The built-in `test` module provides helpful assertion functions for your tests:

- `test.assert_eq(left, right)`: Panics if the two values are not equal. This is the most common assertion.
- `test.assert(condition, "message")`: Panics if `condition` is false.
- `test.assert_ne(left, right)`: Panics if the two values are equal.

```boba
#[test]
fn test_various_assertions() {
    let result = 2 + 2
    test.assert_eq(result, 4)
    test.assert(result > 3, "Result should be greater than 3")
    test.assert_ne(result, 5)
}
```

## Unit Testing Your Code

The idiomatic way to organize tests in Boba is the "Designated Tester" pattern. This pattern uses a simple file naming convention to link your implementation to its tests.

Your implementation code lives in a file like `my_math.boba`, and your unit tests live in a corresponding file named `my_math_test.boba`. This keeps tests close to the code they're testing while maintaining clear separation:

Let's refactor our previous example into this structure.

**File: `src/my_math.boba`**
```boba
//! A module for performing simple math.

/// Adds two numbers. This is part of the public API.
pub fn add(a: int, b: int) -> int {
    return internal_add(a, b)
}

// This helper function is PRIVATE to this module.
fn internal_add(a: int, b: int) -> int {
    return a + b
}
```

**File: `src/my_math_test.boba`**
```boba
//! Unit tests for the my_math module.

#[test]
fn test_public_add_function() {
    test.assert_eq(add(5, 10), 15)
}
```

Appending `_test.boba` tells the compiler that `my_math_test.boba` is the official unit test file for `my_math.boba`.

## Testing Implementation Details

Designated unit test files have special permission to access private, non-`pub` items from their corresponding implementation file. This allows you to test internal implementation details without making them public.

This design lets you write thorough tests for your module's internal logic while maintaining a strictly controlled public API:

Let's add a test for our private `internal_add` function.

**File: `src/my_math_test.boba`**
```boba
//! Unit tests for the my_math module.

#[test]
fn test_public_add_function() {
    test.assert_eq(add(5, 10), 15)
}

#[test]
fn test_private_internal_add_function() {
    // Accessing private functions is allowed ONLY because it is a unit test file.
    // We can directly test our internal implementation details.
    test.assert_eq(internal_add(3, 4), 7)
}
```

This ability to test private functions is a key feature of Boba's unit testing philosophy. This allows you to write thorough tests for your module's internal logic while still maintaining a strictly controlled public API for consumers of your library.

## Integration Testing Your Public API

Integration tests verify your library's public API from an external user's perspective. These tests live in a dedicated, top-level `tests/` directory and can only access `pub` functions.

Each file in the `tests/` directory is treated as a separate test program, ensuring tests remain isolated and focused:

```
my_project/
├── src/
│   └── my_math.boba
└── tests/
    └── public_api_test.boba
```

**File: `tests/public_api_test.boba`**
```boba
// We need to import the public functions from our library.
import { add } from "../src/my_math.boba"

#[test]
fn test_add_from_an_external_perspective() {
    // This tests the public API.
    test.assert_eq(add(100, 200), 300)
}
```

This clear separation—unit tests alongside the code with special access, and integration tests in `tests/` that consume the public API—helps you build a comprehensive and robust test suite.

Boba's `test` module and attributes provide more tools for specific situations.

## Advanced Testing Techniques

### Testing Panics

To verify that your code correctly panics under error conditions, add the `#[should_panic]` attribute to your test function. This inverts the normal test logic - the test passes if the code panics:

```boba
#[test]
#[should_panic]
fn test_add_overflow_panics() {
    let max_int = 9223372036854775807 // int.MAX
    add(max_int, 1)
}
```

### Testing Documentation Examples

Boba can run your `@example` blocks as tests, ensuring your documentation never becomes outdated. This powerful feature guarantees that your examples always work as advertised:

```boba
/// Adds two numbers together.
///
/// @example
/// let result = add(2, 3)
/// test.assert_eq(result, 5)
///
pub fn add(a: int, b: int) -> int {
    return a + b
}
```

When you run `boba test --doc`, the code in the `@example` block will be executed as a test.

Run the `test` command with the `--doc` flag:

```sh
boba test --doc
```

## Time to Practice!

Experiment with testing to build confidence in your code:

1. **Write basic tests**: Create test functions using `#[test]` attribute
2. **Use assertions**: Practice with `assert_eq`, `assert`, and `assert_ne`
3. **Try unit testing**: Create `_test.boba` files for your modules
4. **Test private functions**: Access internal implementation details in unit tests
5. **Write integration tests**: Test your public API from the `tests/` directory
6. **Test documentation**: Add `@example` blocks to your function documentation

## What's Next

You now understand how to verify your code works correctly using Boba's testing tools. Testing gives you confidence to make changes and helps catch bugs early. Next, you'll learn about the `Result` type, which provides a structured way to handle operations that might fail, making error handling explicit and safe.
