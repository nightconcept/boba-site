---
title: "Matching"
description: "Learn how to use Boba's powerful 'match' statement for elegant control flow and pattern matching."
---

Boba provides a powerful `match` statement for checking a variable against a series of possible values. It's a clean and expressive way to handle multiple distinct cases.

## Matching on Enums and Literals

A `match` statement is often used with `enum` types, but it works just as well with simple literal values like numbers and strings.

```boba
// Matching on an enum
enum TrafficLight { RED, YELLOW, GREEN }
var light = TrafficLight.RED

match light {
  TrafficLight.RED => print("Stop!"),
  TrafficLight.YELLOW => print("Caution!"),
  TrafficLight.GREEN => print("Go!"),
  _ => print("Light is broken.")
}

// Matching on a number
var statusCode: int = 200
match statusCode {
  200 => print("OK"),
  404 => print("Not Found"),
  _ => print("Unknown status")
}
```

## Advanced Pattern Matching

Boba's `match` statement can do much more than simple value checking. You can bind matched values to new variables, match on types, and use `where` clauses for complex conditions.

```boba
// To demonstrate type matching, we need a variable that can hold different types.
// We'll use a function that returns a value of type `any`.
fn get_random_value() -> any {
  // In a real program, this might return different types based on some logic.
  // For this example, we'll just return a number.
  return 150
}

var myVariable = get_random_value()

match myVariable {
  1 => print("It was one!"),
  s: string => print("It's a string of length {s.len()}"),
  n: int where n > 100 => print("It's a big number: {n}"),
  _ => print("Default case")
}
```

With `match`, you can write incredibly clear and robust logic. In the next chapter, we'll learn how to organize our code into reusable blocks called functions.