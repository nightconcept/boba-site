---
title: "Chapter 13: Concurrent Programming: async and await"
description: "Learn how to write non-blocking, asynchronous code in Boba using `async` and `await`."
---

Asynchronous programming is essential for building responsive and efficient applications, especially when dealing with tasks like network requests or file I/O that can take time. Boba makes writing asynchronous, non-blocking code as easy and readable as traditional, synchronous code.

## The `async` and `await` Keywords

Boba's concurrency model is built around two keywords: `async` and `await`.

-   **`async`**: A keyword that modifies a function declaration (`async fn ...`). An `async` function does not block when called. Its return type is implicitly wrapped in a `Future<T>` (or a similar construct) that is managed by the Boba runtime.
-   **`await`**: An operator that can only be used inside an `async` function. It pauses the execution of the async function until the `Future` it is waiting on has completed, at which point it unwraps the result. While the function is paused, the Boba runtime is free to execute other tasks.

For JavaScript/TypeScript developers, this model is identical to `async/await` with `Promise<T>`. A Boba `Future<T>` is conceptually the same as a JavaScript `Promise<T>`.

## Example: A Single Asynchronous Call

Let's start with a simple case. Imagine we just want to fetch a user from a database, which is a slow operation. The `async fn` doesn't block our program.

```boba
async fn fetch_user_by_id(id: int) -> User { /* ... */ }

// In another function
print("About to fetch user...")
// The `await` keyword pauses this function until the user data is returned.
let user = await fetch_user_by_id(101)
print("Fetch complete! User is {user.name}")
```

This allows other tasks to run while the function is waiting for the database.

## The Power of Composition: `await` with `?`

Things get really powerful when an `async` function can also fail, returning a `Result`. Boba lets you compose `await` and the `?` operator to handle both asynchrony and errors in a single, clean expression.

```boba
// This async function can fail, so it returns a Result.
async fn fetch_user(id: int) -> Result<User, error> { /* ... */ }

// Note the `?` after await!
let user = await fetch_user(user_id: user_id)?
```
This one line does two things:

- It `await`s the `Future` to complete.
- If the result is an `Err`, the `?` operator propagates it immediately. If it's `Ok`, it unwraps the `User` value and assigns it to the variable.

This elegant composition is key to writing robust, readable asynchronous Boba code.

## Pattern: Concurrent Fetching

Let's look at a practical example where we need to fetch a user's profile and their permissions from two different API endpoints concurrently.

```boba
//! Example of fetching data concurrently.

/// Fetches the user profile from one API.
async fn fetch_user(id: int) -> Result<User, error> { /* ... */ }

/// Fetches the user's permissions from another API.
async fn fetch_permissions(id: int) -> Result<Permissions, error> { /* ... */ }

/// Gets a complete user profile by running fetches concurrently.
async fn get_full_profile(user_id: int) -> Result<FullProfile, error> {
  print("Starting profile fetch for user {user_id}")

  // Start both fetches without blocking.
  // The `async` functions immediately return a Future.
  let user_future = fetch_user(user_id: user_id)
  let perms_future = fetch_permissions(user_id: user_id)

  // Now, `await` the results.
  // The code will pause here until `user_future` is complete.
  let user = await user_future?
  // Then it will pause here until `perms_future` is complete.
  let permissions = await perms_future?

  print("Both fetches complete. Assembling profile.")
  return Ok(FullProfile{ user: user, permissions: permissions })
}
```

By starting both operations before awaiting either, we allow the Boba runtime to work on both tasks in parallel, significantly reducing the total wait time. This powerful pattern is fundamental to writing high-performance Boba applications.

## Chapter Summary

- Use the `async fn` syntax to create a non-blocking, asynchronous function that returns a `Future<T>`.
- Use the `await` keyword inside an `async fn` to pause execution and wait for a `Future` to complete.
- Compose `await` with the `?` operator (`await ... ?`) to elegantly handle `async` functions that return a `Result`.
- To run multiple `async` functions concurrently, call them first to get their `Future`s, and only then `await` the results.