---
title: "Chapter 14: Writing Idiomatic Boba: Style & Philosophy"
description: "Learn the official Boba code style and the philosophy behind it."
---

## Functional Principles: Transform Data, Don't Mutate

While Boba is a multi-paradigm language and not strictly functional, its design and standard library conventions strongly encourage a pure functional style wherever possible.

A **pure function** is a function that has two key properties:

1.  **Deterministic:** Given the same input, it will always return the same output.
2.  **No Side Effects:** It does not modify any state outside of its own scope (like changing a global variable or writing to a file).

Writing code with pure functions makes it easier to test, reason about, and verify, both for humans and for automated tools.

This philosophy is a design guideline, not a strict compiler rule. The core idea is that functions that transform data should return **new** data rather than modifying their inputs in-place.

A function that *does* mutate its input should have a name that makes this behavior explicit (e.g., `sort_in_place`).

### Example: Purity in the Standard Library

Let's see how this principle applies to a common task: sorting a list.

```boba
let original_list = [3, 1, 2]

// PURE: The sorted() function returns a NEW, sorted list.
let sorted_list = original_list.sorted()

// The original list is untouched.
print(original_list) // Output: [3, 1, 2]

// The new list contains the sorted data.
print(sorted_list) // Output: [1, 2, 3]
```

For cases where performance is critical and you want to avoid allocating a new list, a separate, clearly-named "impure" version is provided.

```boba
// IMPURE (but clearly named): The sort_in_place() method modifies the list.
var mutable_list = [3, 1, 2]
mutable_list.sort_in_place()

// The original list has been mutated.
print(mutable_list) // Output: [1, 2, 3]
```

## The Boba Style Guide (boba-fmt)

A single, consistent code style is a cornerstone of the Boba ecosystem. It eliminates debates over formatting and makes all Boba code instantly familiar, which significantly improves readability and maintainability.

The official tool, `boba-fmt`, automatically formats your code to match these rules.

### The `boba-fmt` v1.0 Ruleset

#### Naming Conventions

-   **`PascalCase`** for all types (`struct`, `enum`).
-   **`snake_case`** for all values (functions, methods, variables).
-   **`SCREAMING_SNAKE_CASE`** for program-wide constants (declared with `let`).

#### Formatting

-   **Indentation:** 2 spaces.
-   **Braces:** Opening brace (`{`) on the same line as the declaration (e.g., `fn my_func() {`).
-   **Line Length:** A soft limit of 100 characters. `boba-fmt` will try to adhere to this, but may exceed it for readability.

#### Documentation

-   All `pub` items (functions, structs, etc.) should have BobaDoc comments. This is a strong convention that makes your public APIs easy to understand and use.

### Example of "Perfect" Boba Code

Here is a small example that follows all the `boba-fmt` style rules.

```boba
//! A module for managing player data.

let DEFAULT_HEALTH = 100

/// Represents a player in the game.
struct Player {
  name: string,
  score: int,
}

/// Creates a new player with a default score.
/// @param name: The name for the new player.
/// @returns: A new `Player` struct.
pub fn new_player(name: string) -> Player {
  return Player{
    name: name,
    score: 0,
  }
}