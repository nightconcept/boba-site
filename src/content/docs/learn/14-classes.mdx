---
title: "Classes & Inheritance"
description: "Learn how to create complex objects with data and behavior using classes, methods, initializers, and inheritance in Boba."
---

Classes are a powerful feature in Boba that allow you to create complex objects that have both data (properties) and behavior (methods). They are similar to structs, but with the added ability to define methods and use inheritance.

## Defining a Class

You define a class using the `class` keyword.

```boba
class Enemy = {
  health: int = 100

  pub fn take_damage(amount: int) -> void {
    self.health = self.health - amount
  }

  // Class private functions are only accessible within the class
  fn heal(amount: int) -> void {
    self.health = self.health + amount
  }
}
```

The `self` keyword refers to the current instance of the class, allowing you to access its properties and methods.

## Creating an Instance of a Class

You create an instance of a class using the `new` keyword.

```boba
var enemy = new Enemy()
```

## Initializers

Classes have a special `init` block that acts as a constructor. It's called when you create a new instance and is perfect for setting up the initial state of an object. You can even add parameters to it.

```boba
class Enemy = {
  health: int

  // This init block takes a parameter to set the starting health
  init(start_health: int) {
    self.health = start_health
  }

  pub fn take_damage(amount: int) -> void {
    self.health = self.health - amount
  }
}

// Create a regular enemy and a powerful boss
var minion = new Enemy(100)
var boss = new Enemy(500)

print("Boss health: {boss.health}") // Prints "Boss health: 500"
```

## Accessing Properties and Methods

You can access the properties and methods of a class instance using dot notation.

```boba
enemy.take_damage(20)
print("Enemy health: {enemy.health}") // Prints "Enemy health: 80"
```

## Inheritance

Boba supports inheritance, which allows you to create a new class (a "child" or "subclass") that inherits the properties and methods of an existing class (a "parent" or "superclass").

When a child class has its own `init` block, it **must** call the parent's initializer using `super()`. This ensures that the parent part of the object is properly set up before the child adds its own properties.

Let's see it in action.

```boba
// --- The Parent Class ---
class Enemy {
  health: int
  name: string

  // The parent initializer requires a name to be provided.
  init(name: string) {
    self.health = 100
    self.name = name
    print("{self.name} (an Enemy) has been created.")
  }

  pub fn take_damage(amount: int) -> void {
    self.health = self.health - amount
  }
}


// --- The Child Class ---
class Goblin extends Enemy {
  gold: int

  // The Goblin's initializer takes the arguments it needs.
  init(name: string, gold_pieces: int) {
    // 1. Call the parent's init FIRST and pass the required 'name' up to it.
    // This is mandatory.
    super(name)

    // 2. Now that the 'Enemy' part is initialized, we can initialize
    //    the fields specific to the Goblin.
    self.gold = gold_pieces
    print("...and it's a Goblin with {self.gold} gold!")
  }

  pub fn taunt() {
    // We can now safely use 'self.health' because super() was called.
    print("{self.name} the Goblin taunts! Health: {self.health}, Gold: {self.gold}")
  }
}


// --- Usage ---
var weak_goblin = new Goblin("Gribbly", 12)
// Output:
// > Gribbly (an Enemy) has been created.
// > ...and it's a Goblin with 12 gold!

weak_goblin.taunt()
// Output:
// > Gribbly the Goblin taunts! Health: 100, Gold: 12
```

Classes are a cornerstone of object-oriented programming. But now that you know about both structs and classes, when should you use each one? We'll answer that critical question in the next chapter.
