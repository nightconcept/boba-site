---
title: "Modules"
description: "Learn how to organize your Boba code into multiple files and share code between them using the `import` keyword."
---

As your programs grow larger, organizing code into multiple files becomes essential for maintainability. Boba's module system follows simple, intuitive rules that promote good software architecture.

Each `.boba` file is its own module, with items private by default. You must explicitly mark items as `pub` to make them accessible from other modules. This design encourages intentional API design and prevents accidental coupling between modules.

## Importing from the Standard Library

Boba comes with a standard library of useful modules for common tasks like file system access, mathematical operations, and string manipulation. Standard library modules use the `std:` prefix to distinguish them from your own modules.

To use a standard library module, you import it with the `std:` prefix:

```boba
// The compiler knows `fs` is a built-in standard library module.
import std:fs

// This brings the `fs` namespace into scope.
let contents = fs.read("my_file.txt")
```

## Module Organization

For the following examples, assume you have two files, `utils.boba` and `main.boba`, located together in the same directory. This demonstrates how to structure related functionality across multiple files:

## Importing Specific Items

To import specific items from a file, you use the `import { item } from "path"` syntax. This selective importing keeps your namespace clean and makes dependencies explicit.

You can list items by name inside curly braces `{}`, and optionally rename them with `as` to avoid naming conflicts:

```boba
// in utils.boba
pub fn say_hello() {
    print("Hello!")
}
pub fn say_goodbye() {
    print("Goodbye!")
}

// in main.boba
// The `./` is important! It tells Boba to look in the current directory.
import { say_hello, say_goodbye as farewell } from "./utils.boba"

say_hello() // Prints "Hello!"
farewell() // Prints "Goodbye!"
```

File paths can also point to files in subdirectories, such as "./helpers/strings.boba".

## Importing Everything as a Namespace

To import all public items from a file as a single namespace, you can use the `import * as namespace from "path"` syntax. This approach groups related functionality under a common name, making it clear where each function comes from:

## Time to Practice!

Experiment with modules to understand code organization:

1. **Create separate modules**: Split functionality across multiple `.boba` files
2. **Use `pub` strategically**: Design clean public APIs for your modules
3. **Import selectively**: Practice importing only what you need
4. **Try namespace imports**: Group related functionality under namespaces
5. **Use standard library**: Import and use `std:` modules like `std:fs` or `std:math`

## What's Next

You now understand how to organize code using Boba's module system. This enables you to build larger, more maintainable programs by separating concerns and creating clear boundaries between different parts of your code. Next, you'll learn about testing, which helps ensure your modules work correctly and continue to work as you make changes.

```boba
// in utils.boba
pub fn say_hello() {
    print("Hello!")
}
pub fn say_goodbye() {
    print("Goodbye!")
}

// in main.boba
// The `import * as ...` syntax imports all public items under a single namespace.
import * as utils from "./utils.boba"

utils.say_hello()
utils.say_goodbye()
```
