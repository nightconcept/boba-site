---
title: "Pattern Matching"
description: "Learn how to use the powerful `match` statement for exhaustive pattern matching."
---

Pattern matching is Boba's powerful tool for control flow that lets you check a value against a series of patterns in a clean, expressive way. Its key strength is compiler-enforced **exhaustiveness** - you must handle every possible case.

This exhaustiveness makes pattern matching perfect for safely working with enum types like `Option` and `Result`, ensuring you never forget to handle a case that could cause runtime errors.

## The Rule of Exhaustiveness

A `match` statement in Boba must be **exhaustive** - you must provide a branch for every possible value the type can have. The compiler will give you an error if you forget a case, preventing bugs from unhandled scenarios.

The `match` statement is most powerful when used with types that have a fixed number of variations, like `Option` and `Result`:

```boba
// Safely unwrapping an Option
match find_user(1) {
    Some(name) => print(f"Found user: {name}"),
    None => print("User not found.")
}
```

`match` works just as effectively on the `Result` type. Here's how you can handle a function that might return an error:

```boba
fn read_config_file() -> Result<string, error> {
    // This function might return Ok("file content") or Err({message: "..."})
    // ...
}

match read_config_file() {
    Ok(content) => print(f"Config file content: {content}"),
    Err(err) => print(f"Failed to read config: {err.message}")
}
```

## Binding Values from Patterns

The real power of match is its ability to deconstruct a type and bind the values inside its variants to new variables. In a branch like `Some(name) => ...`, a new variable `name` is created and is only available within that specific branch.

This allows you to check for a variant and use its inner value in a single, clean operation:

```boba
match find_user(1) {
    // The `user_name` variable is created here and holds the string from inside `Some`.
    Some(user_name) => print(f"The user's name is {user_name}."),
    None => print("No user was found.")
}
```

## Conditional Guards

Sometimes, a pattern alone isn't specific enough. You can add a conditional guard to a match arm using `if`. The branch will only be taken if both the pattern matches and the condition evaluates to true.

This allows for more complex logic within your match statements:

```boba
// Multi-line match statement example
fn get_player_status(health: Option<int>) -> string {
  // The match statement itself is an expression, so its result
  // can be directly returned or assigned.
  match health {
    Some(h) if h == 100 => {
      return "Player is at full health."
    },

    Some(h) if h > 50 => {
      let message = f"Player is doing okay with {h} health."
      return message
    },
    Some(h) => {
      return f"Player is in critical condition with only {h} health!"
    },
    None => {
      return "Player status is unknown or offline."
    },
  }
}

// Single-line match statement example
struct Error {
  code: int,
}

match response {
  Ok(data) => print(f"Success! Received data: {data}"),
  Err(e) if e.code == 404 => print("Error: Not Found."),
  Err(_) => print("An unknown error occurred."), // Using '_' as a catch-all
}
```

## Exhaustiveness Guarantees

Exhaustiveness is not just a conventionâ€”it's a compiler guarantee. If you write a `match` statement for an `Option` and forget to handle the `None` case, your code will not compile. The compiler ensures you have considered all cases before your program can run.

While `_` is necessary for matching on types with many possible values (like `int` or `string`), use it cautiously with enums. The wildcard can bypass exhaustiveness checks, potentially hiding bugs when new variants are added later.

## The Default Case: `_`

Sometimes, you don't want to handle every single case explicitly. The wildcard pattern (`_`) serves as a default or "catch-all" branch that matches any value not handled by preceding branches.

This is useful when matching on types with many possibilities, like numbers or strings:

```boba
var status_code: int = 418

match status_code {
    200 => print("OK"),
    404 => print("Not Found"),
    // The `_` handles every other possible integer value.
    _ => print("An unexpected error occurred.")
}
```

## Time to Practice!

Experiment with pattern matching to master this powerful feature:

1. **Match on enums**: Practice exhaustive matching with `Option` and `Result`
2. **Use binding**: Extract values from enum variants into variables
3. **Add guards**: Use `if` conditions to refine pattern matching
4. **Try wildcards**: Use `_` for catch-all cases on numeric types
5. **Combine patterns**: Create complex matching logic with multiple conditions

## What's Next

You now understand how to use pattern matching for safe, exhaustive control flow. This powerful feature ensures you handle all possible cases, preventing runtime errors from forgotten scenarios. Next, you'll learn about defer and panic - mechanisms for cleanup and handling truly exceptional situations that can't be recovered from.