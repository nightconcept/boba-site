---
title: "Chapter 2: Core Building Blocks: Variables & Data Types"
description: "Learn Boba's core principle of immutability-by-default and explore its fundamental data types."
---

import { Aside } from '@astrojs/starlight/components';

In Boba, you can store data in variables. A core principle of the language is **immutability by default**, which helps you write safer, more predictable code.

### `let`: Immutable Bindings

The `let` keyword declares an **immutable binding**. Once a value is assigned, it cannot be changed. This should be your default choice for everything, as it prevents accidental modification.
```boba
// An immutable binding for a regular variable.
let message = "Hello, Boba!"
message = "Hello, Dave!" // COMPILE ERROR: This is NOT allowed.
```

> **A Note for JavaScript/TypeScript Developers**
>
> In Boba, `let` creates a binding that cannot be reassigned, similar to `const` in JavaScript. This is different from JavaScript's `let`, which creates a mutable variable. For mutable variables in Boba, you must use `var`.

### Convention: Using `let` for Constants
Boba uses a combination of an immutable `let` binding and a naming convention for program-wide constants. By convention, these values are given `SCREAMING_SNAKE_CASE` names to signal to other developers that they represent a foundational, constant value within the program's domain.

```boba
let MAX_HEALTH = 100
let PI = 3.14159
```

### `var`: Mutable Variables

You should only use the `var` keyword when you have a specific and necessary reason to change a value after it's been created.

```boba
// A mutable variable, used only when mutation is required.
var counter = 0
counter = counter + 1 // This is allowed.
```

By defaulting to `let` for everything, you make your code's intent clearer and safer.

### Type Inference: Letting Boba Do the Work

In the examples, you may have noticed that sometimes we declare a type (`let score: int = 100`) and sometimes we don't (`let current_level = 10`). When you assign a value as you declare a variable, Boba can usually figure out, or infer, the type for you. `10` is clearly an `int`, `"Ada"` is a `string`, and `true` is a `boolean`. This is a convenience feature to keep your code concise. You should add an explicit type annotation when it helps improve clarity or when you want to be more specific than the inferred default (e.g., `let price: float = 20` instead of letting it be an `int`).

## Primitive Types

Boba has a set of primitive types that are the building blocks of data in your programs.

### `int`

The `int` type is used to represent a 64-bit signed integer (a whole number). It is the ideal type for counting, indexing into collections, representing IDs, and any situation where fractional values are not needed.
```boba
let score: int = 100
let current_level = 10 // Inferred as int

var quantity: int = 3
var drinks_bought = 50 // Inferred as int
```

##### Writing Numbers in Different Bases

In addition to standard decimal (base-10) numbers, Boba supports hexadecimal and binary notations, which are common in systems programming, graphics, and data manipulation.

- **Hexadecimal (base-16):** Prefix the number with `0x`. Uses digits `0-9` and letters `a-f`.
- **Binary (base-2):** Prefix the number with `0b`. Uses only digits `0` and `1`.

No matter how you write the number, it's still just an `int` with the same value.
```boba
// All of these variables hold the exact same integer value: 255
let decimal_value: int = 255
let hex_value: int = 0xFF
let binary_value: int = 0b11111111

print(decimal_value == hex_value) // Prints "true"
print(hex_value == binary_value) // Prints "true"
```

##### Improving Readability with `_`

Long number literals can be difficult to read. Boba allows you to use an underscore `_` as a visual separator anywhere inside a number. The compiler completely ignores it.

This works for `int` and `float` types, as well as for hex and binary notations.
```boba
// These are easier to read thanks to the '_' separator.
let one_billion: int = 1_000_000_000
let pi: float = 3.141_592_653

// This is especially useful for hex and binary values.
let packed_color: int = 0xFF_AB_00_FF
let permission_flags: int = 0b1010_1111
```

### `float`

The `float` type is used to represent a 64-bit double-precision floating-point number. It is the correct type for scientific calculations, measurements, or any value that may have a fractional component.

```boba
let price: float = 19.99
let PI: float = 3.14159 // Constant
let milk_percentage = 0.02 // Inferred as float due to the decimal point.

var piggy_bank_value: float = 50.43
var temperature = 25.5
var test_grade = 90.0 // Inferred as float due to the decimal point when it is .0
```
Note: While floats are powerful, be mindful of standard precision limitations inherent to floating-point arithmetic.

### `string`

The `string` type is used to represent text.

```boba
let message: string = "Hello, Boba!"

var player_name = "June" // Inferred as a string
```
##### Formatting Strings with F-Strings

> To embed variables and expressions directly into a string, Boba uses **f-strings**. An f-string is a string literal prefixed with the letter `f`. This explicitly tells the compiler to process any expressions inside curly braces `{}`.

```boba
let player_name = "Ada"
let level: int = 10

// Use an f-string to create a formatted message.
let welcome_message = f"Welcome, {player_name} (Level {level})!" 
print(welcome_message) // Outputs: Welcome, Ada (Level 10)!

// Regular strings do not process the braces.
let template = "This is a template: {some_value}"
print(template) // Outputs: This is a template: {some_value}
```

### `boolean`

The `boolean` type represents a value that can be either `true` or `false`. Booleans are essential for controlling the flow of your program.

```boba
var is_game_over: boolean = false
var has_key = true // Inferred as a boolean
```

## Composite Types

Boba also has composite types, which are made up of primitive types.

### `list`

A `list` is an ordered collection of values of the same type. Lists are dynamic, meaning you can add or remove items.

```boba
// A list of numbers
var highScores: int[] = [100, 95, 80]

// A list of strings
var ingredients: string[] = ["flour", "sugar", "boba pearls"]
```

You can perform many operations on lists, like getting their size or adding new items.

```boba
print(ingredients.len()) // Outputs: 3

// Add a new item to the end
ingredients.push("tapioca pearls")
print(ingredients.len()) // Outputs: 4

// Access items by their index (starting from 0)
print(ingredients[0]) // Outputs: "flour"
```

### `map`

A `map` is a collection of key-value pairs. Each key must be unique, and all keys must be of the same type, as must all values.

```boba
// Create a map with string keys and number values
var scores: [string:int] = {
  "ada": 100,
  "grace": 95
}

// Check its initial size
print(scores.len()) // Outputs: 2

// Insert a new key-value pair
scores["boba"] = 105

// Check the new size
print(scores.len()) // Outputs: 3
```

Accessing a key in a map returns a special `Option` type to safely handle cases where the key might not exist. We will cover this powerful feature in a **later chapter**.

## Chapter Summary

- Use `let` for immutable bindings by default, which is Boba's version of a constant.
- Use `var` only when you specifically need to change a variable's value.
- Boba has familiar primitive types (`int`, `float`, `string`, `boolean`) and composite types (`list`, `map`).
- Boba often uses type inference to determine a variable's type from its initial value.