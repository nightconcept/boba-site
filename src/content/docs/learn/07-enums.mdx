---
title: "Enums"
description: "Learn how to create your own custom types with a fixed set of variants using enums."
---

Enums let you define custom types that can only be one of a specific, fixed set of possible values, called 'variants'. This is incredibly useful for modeling state in your programs, ensuring that variables can only hold valid values that you've explicitly defined.

Instead of using strings like "pending", "complete", or "failed" (which could be misspelled or mistyped), enums give you compile-time guarantees that only valid states are possible. This prevents entire classes of bugs before your program even runs.

## Defining an Enum

You define an enum with the `enum` keyword, listing all its possible variants. Each variant is a valid value that variables of this enum type can hold:

```boba
// This enum can only be one of three possible values.
enum JobStatus {
  Pending,
  Complete,
  Failed
}
```

> **Pro-Tip: Enums with Data**
>
> In Boba, enum variants can also hold data. For example, you could define `Failed(string)` to store an error message right inside the variant. This powerful feature for modeling complex state will be covered in a later chapter.

## Using an Enum

Once defined, you can use the enum as a type for variables and function parameters. You access a specific variant using `EnumName.VariantName`. To act on the value of an enum, you use a `match` statement.

The `match` statement is exhaustive - the compiler guarantees that you handle every possible variant, preventing bugs from unhandled cases. This safety feature ensures your code can never encounter an unexpected state:

```boba
// Create a variable of type JobStatus.
let current_status: JobStatus = JobStatus.Pending

match current_status {
  JobStatus.Pending => print("The job is waiting to be processed."),
  JobStatus.Complete => print("The job finished successfully."),
  JobStatus.Failed => print("The job failed to complete.")
}
```

## Enum Benefits

Enums leverage the compiler as a safety net. It becomes impossible for a `JobStatus` variable to ever hold an invalid value like "in-progress" or "error". This eliminates an entire category of bugs at compile time.

Enums also make your code self-documenting - anyone reading your code can immediately see all possible states by looking at the enum definition. This clarity reduces confusion and makes maintenance easier.

## Time to Practice!

Experiment with enums to understand their power:

1. **Create simple enums**: Define enums for different states in your domain
2. **Use match statements**: Practice handling all variants exhaustively  
3. **Try enum methods**: Create functions that take enums as parameters
4. **Compare to strings**: See how enums prevent typos that strings allow

## What's Next

You now understand how to create custom types with fixed sets of values using enums. This provides compile-time safety for state management. Next, you'll learn about structs, which let you group related data together into custom types, complementing enums for comprehensive type design.