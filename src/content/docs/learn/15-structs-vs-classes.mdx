---
title: "Structs vs. Classes: The Key Difference"
description: "Understand the crucial difference between value types (structs) and reference types (classes) to make the right choice in your code."
---


In Boba Lang, both `structs` and `classes` allow you to create custom data structures, but they have one fundamental difference that impacts how you use them: the way they are handled when assigned or passed to functions. Understanding this distinction is crucial for writing correct and efficient code.

The core difference is **value semantics** vs. **reference semantics**.

-   **Structs** are *value types*. When you assign a struct to a new variable or pass it to a function, the entire struct is *copied*.
-   **Classes** are *reference types*. When you assign a class instance to a new variable, you are not creating a copy. Instead, you are creating a *reference* (or a pointer) to the exact same object in memory.

## A Practical Example

Let's see this in action.

### Structs: Copies on Assignment

Imagine we have a simple `Point` struct. When we assign `p1` to `p2`, we create a completely independent copy. Changing `p2` has no effect on `p1`.

```boba
// Struct (Value Type)
struct Point {
    x: number
}

var p1 = Point { x: 10 }
var p2 = p1 // p2 is a NEW copy of p1

// Modify the copy
p2.x = 20

print("p1.x is still {p1.x}") // Output: p1.x is still 10
print("p2.x is now {p2.x}")   // Output: p2.x is now 20
```

### Classes: References on Assignment

Now, consider an `Enemy` class. When we assign `e1` to `e2`, both variables point to the *same object*. Modifying the object through `e2` will be reflected when we access it through `e1`.

```boba
// Class (Reference Type)
class Enemy {
    var health: number

    init(start_health: number = 100) {
        self.health = start_health
    }

    fn take_damage(amount: number) {
        self.health = self.health - amount
    }
}

var e1 = new Enemy()
var e2 = e1 // e2 is a REFERENCE to the SAME object as e1

// Modify the single object via the second reference
e2.take_damage(20)

print("e1.health is now {e1.health}") // Output: e1.health is now 80
print("e2.health is now {e2.health}") // Output: e2.health is now 80
```

Notice the `init` block in the `Enemy` class, which acts as a constructor, contrasts with the direct literal initialization used for the `Point` struct. This highlights another common difference between reference and value types in Boba.

## When to Use Which?

Here are some simple rules of thumb for deciding between a `struct` and a `class`:

**Use a `struct` when:**

-   The data is simple and self-contained (e.g., a 2D point, an RGB color, a size).
-   You want to ensure that the data is not changed by another part of your program unexpectedly.
-   The primary purpose is to group a few related values together.
-   You don't need inheritance.

**Use a `class` when:**

-   You need a single, shared instance of an object that multiple parts of your program can interact with and modify (e.g., a game character, a database connection, a user profile).
-   The object has a distinct identity and lifecycle.
-   You want to use inheritance to create specialized versions of a base class.
-   The object's behavior (methods) is as important as its data.

With this knowledge, you can build well-structured and efficient Boba applications. In the final chapter, we'll learn how to organize your code into separate files.