---
title: "Generics"
description: "Learn about generic types and functions in Boba for writing reusable, type-safe code"
---

Generics allow you to write code that works with different types while maintaining type safety. Instead of duplicating function logic for integers, strings, and other types, you can write one generic function that adapts to whatever type you provide.

This eliminates code duplication while preserving Boba's compile-time type checking. Generics ensure your code is both flexible and safe, catching type mismatches before your program runs.

## Basic Generic Functions

Define generic functions using angle brackets with type parameters. The type parameter (commonly named `T`) acts as a placeholder that gets filled in when you call the function:



```boba
fn get_first<T>(items: List<T>) -> T {
    return items[0]
}

// Works with different types
let numbers = [1, 2, 3]
let first_number = get_first(numbers)  // Returns int

let names = ["Alice", "Bob", "Charlie"]  
let first_name = get_first(names)      // Returns string
```

## Generic Types

Boba has several built-in generic types that you've already been using. When you create a `List<int>` or `Map<string, int>`, you're using generics to specify exactly what types the collection can hold:



```boba
// Lists with specific element types
let numbers: List<int> = [1, 2, 3, 4]
let words: List<string> = ["hello", "world"]

// Maps with key and value types  
let scores: Map<string, int> = {"alice": 100, "bob": 85}

// Tuples with mixed types
let point: (int, int) = (10, 20)
let record: (string, int, bool) = ("Alice", 25, true)
```

## Generic Structs

You can create your own generic types by adding type parameters to struct definitions. This lets you build reusable data structures that work with any type:



```boba
struct Container<T> {
    value: T
}

// Create containers for different types
let int_container = Container{ value: 42 }
let string_container = Container{ value: "hello" }
```

## Generic Enums

Enums can also be generic, allowing variants to hold different types of data. This is how Boba implements powerful types like `Option` and `Result`:



```boba
enum Result<T, E> {
    Ok(T),
    Err(E)
}

let success: Result<int, string> = Result.Ok(42)
let failure: Result<int, string> = Result.Err("Something went wrong")
```

## Type Inference

Boba can often infer generic types from context, reducing the verbosity of generic code. You don't always need to specify the type parameters explicitly:



```boba
// Type inferred from the list contents
let numbers = [1, 2, 3]        // List<int>
let mixed = (42, "hello")      // (int, string)

// Type inferred from function arguments
fn identity<T>(value: T) -> T {
    return value
}

let result = identity(42)      // T inferred as int
```

## Generic Constraints

You can constrain generic types to ensure they have certain capabilities. This advanced feature lets you call specific methods on generic parameters:



```boba
// T must be a specific type or implement certain traits
fn process<T: Comparable>(value: T) -> T {
    // Implementation here
    return value
}
```

## Working with Option and Result

Two important generic types you'll use frequently are `Option<T>` and `Result<T, E>`. These demonstrate how generics enable powerful, reusable error handling patterns:



```boba
import std:test

// Option<T> represents a value that might not exist
let maybe_number: Option<int> = Some(42)
let no_number: Option<int> = None

// Result<T, E> represents success or failure
let success: Result<int, string> = Ok(100)
let error: Result<int, string> = Err("Failed to parse")

// Use pattern matching with generic types
match maybe_number {
    Some(value) => print(f"Got: {value}"),
    None => print("No value")
}
```

## Best Practices

**Use descriptive type parameter names**: `T` for generic types, `K` and `V` for map keys/values. **Prefer type inference** when the compiler can figure it out, but **be explicit with types** when it improves code clarity.

**Use generics** to avoid code duplication while maintaining type safety. They help catch type errors at compile time rather than runtime.

## Time to Practice!

Experiment with generics to understand their flexibility:

1. **Write generic functions**: Create functions that work with multiple types
2. **Use built-in generics**: Practice with `List<T>`, `Map<K, V>`, and `Option<T>`
3. **Create generic structs**: Build reusable data structures
4. **Try type inference**: Let Boba figure out types when possible
5. **Practice with constraints**: Experiment with bounded generic types

## What's Next

You now understand how generics provide type-safe flexibility in Boba. You can write reusable code that works with multiple types while maintaining compile-time safety guarantees. Next, you'll learn about methods, which let you add behavior to your custom types and make them feel like built-in language features.