---
title: "Functions"
description: "Learn how to create reusable blocks of code in Boba with functions."
---

Functions let you organize code into reusable blocks. Boba's function syntax is clean and includes several features that make code more reliable:

```boba
// Simple function
fn say_hello() {
    print("Hello, Boba!")
}

// Function with return value
fn get_greeting(name: string) -> string {
    return f"Hello, {name}!"
}

// Function calls
say_hello()
let message = get_greeting(name: "Developer")
print(message)  // Hello, Developer!
```

## Named Arguments Prevent Bugs

One of Boba's most valuable features is mandatory named arguments for multi-parameter functions. This eliminates a common source of bugs where arguments are passed in the wrong order:

```boba
// Multi-parameter function
fn connect(host: string, port: int, timeout: int) {
    print(f"Connecting to {host}:{port} (timeout: {timeout}s)")
}

// Correct: named arguments required
connect(host: "boba.dev", port: 9000, timeout: 5000)

// Compile error: positional arguments not allowed
// connect("boba.dev", 9000, 5000)

// Single parameter functions don't need names
say_hello()
print("Hello, Boba!")
get_greeting(name: "Boba")
```

## Default Parameters

You can make parameters optional by providing default values. This is especially useful for configuration functions:

```boba
fn connect(host: string, port: int = 8080, use_tls: bool = true) {
    print(f"Connecting to {host}:{port} (TLS: {use_tls})")
}

// Call with defaults
connect(host: "boba.dev")  

// Override specific parameters  
connect(host: "boba.dev", port: 9000)
connect(host: "local", port: 3000, use_tls: false)
```

## Function Visibility

Boba follows the principle of "secure by default" - functions are private unless explicitly made public. This helps maintain clean APIs:

```boba
// Private function (default)
fn internal_helper() {
    print("Only this file can call me")
}

// Public function
pub fn calculate_score(base: int, bonus: int) -> int {
    return base + bonus
}
```

## Closures (Anonymous Functions)

Closures are functions without names that you can create inline and store in variables. Think of them as "function literals" - just like you can write `42` for a number or `"hello"` for a string, you can write `|x| x * 2` for a function.

### Basic Closure Syntax

```boba
// Traditional function
fn double(x: int) -> int {
    return x * 2
}

// Equivalent closure
let double = |x: int| x * 2

// Both work the same way
print(double(5))  // 10
```

### Why Use Closures?

Closures excel in situations where you need a small, simple function that you'll only use once or in a specific context:

```boba
// Instead of defining a named function for simple operations
// (Collections and their methods covered in next chapter)

// Quick calculation without naming the function
let quick_calc = |x: int| x * 2 + 1
print(quick_calc(5))  // 11

// Temporary operations
let tax_rate = 0.08
let add_tax = |price: float| price * (1.0 + tax_rate)
print(add_tax(100.0))  // 108.0
```

### Closures as Function Parameters

You can pass closures to functions, enabling flexible, reusable code:

```boba
// A function that takes another function as input
fn apply_twice(operation: |int| -> int, value: int) -> int {
    return operation(operation(value))
}

// Pass different operations
let result1 = apply_twice(operation: |x| x * 2, value: 3)    // 12 (3*2*2)
let result2 = apply_twice(operation: |x| x + 1, value: 5)    // 7 (5+1+1)

// Or store the closure first
let square = |x: int| x * x
let result3 = apply_twice(operation: square, value: 3)       // 81 (3²²)
```

### Capturing Variables (The "Closure" Part)

Closures can "capture" variables from their surrounding scope, making them more powerful than regular functions:

```boba
fn create_multiplier(factor: int) -> |int| -> int {
    // This closure "closes over" the factor variable
    return |x: int| x * factor
}

let double = create_multiplier(factor: 2)
let triple = create_multiplier(factor: 3)

print(double(5))  // 10 (5 * 2)
print(triple(5))  // 15 (5 * 3)

// Each closure remembers its own factor value
```

### When to Use Closures vs Named Functions

**Use closures for:**
- Short, simple operations
- One-time use functions
- Callback functions
- Operations that depend on local context

**Use named functions for:**
- Complex logic
- Functions used in multiple places
- Public APIs
- Functions that need clear documentation

## Pipe Operator

The pipe operator transforms nested function calls into readable left-to-right chains, making data processing pipelines much clearer:

```boba
// Helper functions
fn trim(s: string) -> string { /* ... */ }
fn to_uppercase(s: string) -> string { /* ... */ }
fn emphasize(text: string) -> string { f"**{text}**" }

// Without pipe operator (nested)
let message = "  hello world  "
let result = emphasize(text: to_uppercase(s: trim(s: message)))

// With pipe operator (linear)
let result = message
    |> trim()
    |> to_uppercase()
    |> emphasize()

// For multi-parameter functions, use placeholder
fn send_message(text: string, prefix: string) -> string {
    return f"{prefix}: {text}"
}

let formatted = message
    |> trim()
    |> to_uppercase()
    |> send_message(prefix: "LOG", text: #)
```

## Function Benefits

Named arguments prevent bugs where parameters are passed in the wrong order, making function calls self-documenting. The `fn` keyword provides a clean, consistent way to define functions, and explicit return types help catch errors early.

Boba's function system combines simplicity with safety - closures are first-class values, visibility is straightforward with just `pub` and private, and the pipe operator enables readable data transformation chains.

## Time to Practice!

Experiment with Boba's function features:

1. **Write simple functions**: Create functions with and without return values
2. **Try named arguments**: Write a function with multiple parameters and call it
3. **Use default parameters**: Create a configuration function with sensible defaults
4. **Experiment with closures**: Store a function in a variable and pass it around
5. **Try the pipe operator**: Chain a few string processing functions together

## What's Next

You now understand how Boba's function system prevents common bugs through named arguments and provides powerful tools like closures and pipe operators. Next, you'll learn about operators and control flow, including Boba's readable logical operators and how `if/else` works as expressions, not just statements.