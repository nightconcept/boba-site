---
title: Boba Syntax Highlighting
description: A demonstration of the Boba language syntax highlighting.
---

This page demonstrates the custom syntax highlighting for the Boba language. For comparison, each Boba example is followed by an equivalent TypeScript example.

## Basic Class and Function Example

```boba
// This is a single-line comment
class Greeter {
  pub fn say_hello(name: string) -> void {
    // Log a greeting to the console
    console.log("Hello, {name}!")
  }
  fn say_bye(name: string) -> void {
    // Log a farewell to the console
    console.log("Bye, {name}!")
  }
}

// Create a new instance of the Greeter class
const greeter = new Greeter()

// Call the say_hello method
greeter.say_hello("Boba")
```

### TypeScript

```typescript
// This is a single-line comment
class Greeter {
  sayHello(name: string): void {
    // Log a greeting to the console
    console.log(`Hello, ${name}!`);
  }

  private sayBye(name: string): void {
    // Log a greeting to the console
    console.log(`Bye, ${name}!`);
  }
}

// Create a new instance of the Greeter class
const greeter = new Greeter();

// Call the sayHello method
greeter.sayHello("TypeScript");
```

## Variables and Types

```boba
// Variable declarations
var counter = 0
const max_value = 100
var message: string = "Welcome to Boba!"
var enabled: boolean = true
var items: [string:string] = {}
```

### TypeScript

```typescript
// Variable declarations
let counter = 0;
const maxValue = 100;
let message: string = "Welcome to TypeScript!";
let enabled: boolean = true;
let items: Record<string, any> = {};
```

## Control Flow and Operators

```boba
// Conditional statements
if counter < max_value and enabled {
    counter++;
    console.log("Counter incremented: {counter}")
} else {
    console.log("Maximum reached or disabled")
}

// Loops and ranges
for i in 1 to 10 by 2 {
    console.log("Odd number: {i}")
}

// While loop
while counter <= max_value {
    counter++
    if counter == 50 {
        break
    }
}
```

### TypeScript

```typescript
// For demonstration, we'll declare variables used in conditions and loops.
let counter = 1;
const maxValue = 100;
const enabled = true;

// Conditional statements
if (counter < maxValue && enabled) {
    counter++;
    console.log(`Counter incremented: ${counter}`);
} else {
    console.log("Maximum reached or disabled");
}

// Loops and ranges
for (let i = 1; i <= 10; i += 2) {
    console.log(`Odd number: ${i}`);
}

// While loop
while (counter <= maxValue) {
    counter++;
    if (counter === 50) {
        break;
    }
}
```

## Functions and Piping

```boba
// Public function definition with arrow syntax
pub fn calculate(x: number, y: number) -> number {
    return x * y + 10
}

// Private function
fn internal_helper(data: table) -> string {
    return data.name |> uppercase() |> trim()
}

class Enemy = {
  health: number = 100

  // Init always exists and does not need fn
  init() {
    self.health = 200
  }

  pub fn take_damage(amount: number) -> void {
    self.health = self.health = self.health - amount
  }

  // Class private functions are only accessible within the class
  fn heal(amount: number) -> void {
    self.health = self.health + amount
  }
}

var goblin: Enemy = new Enemy()

// Piping operator example
const result = calculate(5, 3) |> to_string() |> log()
```

### TypeScript

```typescript
// Function definition with arrow syntax
const calculate = (x: number, y: number): number => {
    return x * y + 10;
};

// Private method in a class (TypeScript uses `private` keyword inside classes)
class DataHelper {
    private internalHelper(data: { name: string }): string {
        return data.name.toUpperCase().trim();
    }
}

// Function chaining is used instead of a pipe operator
const result = calculate(5, 3).toString();
console.log(result);
```

### Python

```python
# Public function definition
def calculate(x: int, y: int) -> int:
    return x * y + 10

# Private function (by convention)
def _internal_helper(data: dict) -> str:
    return data['name'].upper().strip()

class Enemy:
    health: int = 100

    def __init__(self):
        # The constructor initializes instance-specific attributes
        self.health = 200

    def take_damage(self, amount: int) -> None:
        self.health -= amount

    # Private method (by convention)
    def _heal(self, amount: int) -> None:
        self.health += amount

# Instantiate the class
goblin = Enemy()

# Piping can be simulated with nested function calls or method chaining
result_as_string = str(calculate(5, 3))
print(result_as_string)
```

## Enumerations

```boba
enum Color {
  RED,
  GREEN,
  BLUE
}

// Variants are accessed through the enum type itself, like 'Color.GREEN'.
var my_color: Color = Color.GREEN
```

### TypeScript

```typescript
enum Color {
  RED,
  GREEN,
  BLUE
}

// Variants are accessed through the enum type itself, like 'Color.GREEN'.
let myColor: Color = Color.GREEN;
```

## Structs

```boba
struct Player = {
  name: string,
  score: number,
  is_active: boolean
}

var player1: Player = {
  name: "Alice",
  score: 100,
  is_active: true
}
```

### TypeScript

```typescript
interface Player {
  name: string;
  score: number;
  isActive: boolean;
}

const player1: Player = {
  name: "Alice",
  score: 100,
  isActive: true,
};
```

## Match Expressions

```boba
fn get_http_message(status_code: number) -> string {
  match status_code {
    200 => "OK",
    404 => "Not Found",
    s where s >= 500 => "Server Error: {s}",
    _ => "Unknown status"
  }
}

const message = get_http_message(404)
console.log(message)
```

### Rust

```rust
fn get_http_message(status_code: u16) -> String {
    match status_code {
        200 => "OK".to_string(),
        404 => "Not Found".to_string(),
        s if s >= 500 => format!("Server Error: {}", s),
        _ => "Unknown status".to_string(),
    }
}

fn main() {
    let message = get_http_message(404);
    println!("{}", message);
}
```

## Advanced Features

```boba
/* 
   Multi-line comment
   showcasing string interpolation
   and advanced operators
*/
class Calculator extends BaseCalculator {
    fn compute(values: table) -> number {
        var sum = 0
        
        foreach item in values {
            sum += item.value
        }
        
        // Comparison operators
        if sum >= 100 and sum <= 1000 {
            return sum ^ 2  // Exponentiation
        } else if sum > 1000 or sum < 0 {
            return null
        }
        
        return sum
    }
}
```

### TypeScript

```typescript
/*
   Multi-line comment
   showcasing string interpolation
   and advanced operators
*/
// Assuming a BaseCalculator class exists from another file
declare class BaseCalculator {}

class Calculator extends BaseCalculator {
    compute(values: { value: number }[]): number | null {
        let sum = 0;
        
        for (const item of values) {
            sum += item.value;
        }
        
        // Comparison operators
        if (sum >= 100 && sum <= 1000) {
            return sum ** 2;  // Exponentiation
        } else if (sum > 1000 || sum < 0) {
            return null;
        }
        
        return sum;
    }
}
```

## Edge Cases and Special Syntax

```boba
// Numbers and expressions
var pi = 3.14159
var result = (10 + 5) * 2 - 1

// String interpolation in different contexts
var template = "The result is {result} and pi is {pi.toFixed(2)}"

// Table access and methods
var data: table = {
    name: string = "Boba",
    version: number = 1.0
    features: string = ["type safety", "classes", "interfaces"]
}

// Method chaining and property access
var info = data.name
    |> uppercase()
    |> concat(" Language v{data.version}")
    |> display()
```

### TypeScript

```typescript
// Numbers and expressions
let pi = 3.14159;
let result = (10 + 5) * 2 - 1;

// Template literals for string interpolation
let template = `The result is ${result} and pi is ${pi.toFixed(2)}`;

// Object access and methods
let data = {
    name: "TypeScript",
    version: 5.0,
    features: ["type safety", "classes", "interfaces"]
};

// Method chaining and property access
const info = data.name
    .toUpperCase()
    .concat(` Language v${data.version}`);

console.log(info);
```

This comprehensive example showcases all the major syntax highlighting features of the Boba language, including:

- **Comments**: Single-line (`//`) and multi-line (`/* */`)
- **Keywords**: Control flow, loops, and declarations
- **Types**: Primitive types like `string`, `number`, `boolean`, `table`
- **Operators**: Arithmetic, comparison, logical, assignment, and the special piping operator (`|>`)
- **String interpolation**: Using `{expression}` syntax
- **Functions**: Regular and private function declarations
- **Classes**: Class definitions with inheritance
- **Punctuation**: Proper highlighting of braces, brackets, and other delimiters
