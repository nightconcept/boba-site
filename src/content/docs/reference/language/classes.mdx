---
title: Classes
---

Classes are blueprints for creating objects. They bundle data (properties) and functions that operate on that data (methods) into a single unit. Classes in Boba support inheritance, allowing you to create a new class that builds upon an existing one.

## Defining a Class

You define a class using the `class` keyword.

```boba
class Enemy = {
  // Properties
  health: number
  mana: number

  // Initializer - sets starting values
  init() {
    self.health = 100
    self.mana = 50
  }

  // A public method (accessible from outside the class)
  pub fn take_damage(amount: number) -> void {
    // `self` refers to the current instance of the class
    self.health = self.health - amount
    print("Enemy took {amount} damage. Health is now {self.health}.")
  }

  // A private method (only accessible within the class)
  fn regenerate_mana() -> void {
    self.mana = self.mana + 5
  }
}
```

### Properties
Properties are variables that belong to a class instance. They define the state of the object. In the example above, `health` and `mana` are properties.

### Methods
Methods are functions that belong to a class. They define the behavior of the object.
-   **Public Methods**: Declared with the `pub` keyword, they can be called from anywhere you have an instance of the class.
-   **Private Methods**: Declared without `pub`, they can only be called by other methods within the same class.
-   **The `self` Keyword**: Inside a method, the `self` keyword is used to access the properties and other methods of the current object instance.

## Constructors: The `init` Block

The `init` block is a special method in a class that gets called when a new instance of the class is created using the `new` keyword. It's used to set up the initial state of the object. Unlike regular methods, it is defined with the `init` keyword and without `fn`.

### Overloading Initializers

You can define multiple `init` blocks with different parameters. This is called overloading. The compiler determines which `init` block to call based on the arguments you provide to the `new` keyword.

```boba
class Enemy = {
  health: number
  mana: number

  // Default initializer
  // Called by `new Enemy()`
  init() {
    self.health = 100
    self.mana = 50
  }

  // Overloaded initializer with custom health
  // Called by `new Enemy(200)`
  init(start_health: number) {
    self.health = start_health
    self.mana = 50
  }
}
```

### Creating an Instance

When you create a new instance, the arguments you pass to `new` will determine which `init` block is executed.

```boba
// Calls init()
var basic_enemy = new Enemy()
print(basic_enemy.health) // Prints: 100

// Calls init(start_health: number)
var strong_enemy = new Enemy(200)
print(strong_enemy.health) // Prints: 200
```

## Inheritance

Inheritance allows a class (the child or subclass) to inherit the properties and methods of another class (the parent or superclass). This is a core concept of object-oriented programming that promotes code reuse.

You use the `extends` keyword to create a subclass.

```boba
// Goblin is a subclass of Enemy
class Goblin extends Enemy = {
  // Add new properties specific to Goblin
  gold: number = 12

  // Add new methods specific to Goblin
  pub fn taunt() {
    print("Heh heh heh! I have {self.health} health left!")
  }

  // You can also override parent methods (not shown, but possible)
}
```

An instance of `Goblin` has all the properties and methods of `Enemy`, plus its own.

```boba
var goblin_scout = new Goblin()

// Call a method inherited from Enemy
goblin_scout.take_damage(20) // Prints: "Enemy took 20 damage. Health is now 80."

// Access a property from Goblin
print("The goblin has {goblin_scout.gold} gold.") // Prints: "The goblin has 12 gold."

// Call a method from Goblin
goblin_scout.taunt() // Prints: "Heh heh heh! I have 80 health left!"
```
