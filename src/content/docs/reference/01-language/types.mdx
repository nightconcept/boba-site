---
title: Types
---

A type is a classification that tells the compiler or interpreter how a programmer intends to use a piece of data. Boba is a statically-typed language, meaning the type of every variable is known at compile time.

## Primitive Types

Primitive types are the most basic data types available in Boba.

### `string`

A `string` is a sequence of characters used to represent text.

```boba
var name: string = "Boba Fett"
var constant_string = "Immutable" // Type is inferred
```

### `int`

The `int` type is used to represent a 64-bit signed integer (a whole number). It is the ideal type for counting, indexing into collections, representing IDs, and any situation where fractional values are not needed.

```boba
let score: int = 100
let quantity: int = 3
let current_level = 10 // Inferred as int
```

### `float`

The `float` type is used to represent a 64-bit double-precision floating-point number. It is the correct type for scientific calculations, measurements, or any value that may have a fractional component.

```boba
let price: float = 19.99
const PI: float = 3.14159
var temperature = 25.5 // Inferred as float
```
Note: While floats are powerful, be mindful of standard precision limitations inherent to floating-point arithmetic.

### `boolean`

A `boolean` represents one of two values: `true` or `false`. It's primarily used for conditional logic.

```boba
var is_active: boolean = true
var has_permission = false // Type is inferred
```

## Core Data Structures

Boba includes several fundamental composite types for structuring data. For more complex user-defined types, see [Structs, Enums, and Classes](./declarations.mdx).

### List

A `list` is an ordered, dynamic collection of values of the same type, written as `T[]` where `T` is the element type. Lists are used for managing sequences of data where the order matters and the number of items may change. For more details, see the [Collections](./collections.mdx) page.

```boba
var highScores: int[] = [100, 95, 80]
var ingredients: string[] = ["flour", "sugar", "boba pearls"]
```

### Map

A `map` is a collection of key-value pairs, written as `[K:V]` where `K` is the key type and `V` is the value type. Each key must be unique. Maps are ideal for associating data, such as storing properties or creating dictionaries. For more details, see the [Collections](./collections.mdx) page.

```boba
var scores: [string:int] = { "ada": 100, "grace": 95 }
```

### `Option<T>`

The `Option<T>` enum is Boba's primary mechanism for handling values that may be absent, eliminating the need for `null`. An `Option<T>` is either `Some(T)`, containing a value, or `None`, representing absence. This forces developers to handle both possibilities at compile time, leading to safer, more robust code.

```boba
enum Option<T> {
    Some(T), // Represents the presence of a value
    None,    // Represents the absence of a value
}

fn find_user(id: int): Option<string> {
    if id == 1 { return Some("Alice") }
    return None
}
```

### `Result<T, E>`

The `Result<T, E>` enum is used for functions that can return either a success value or an error. It has two variants: `Ok(T)`, which contains the successful result of type `T`, and `Err(E)`, which contains an error of type `E`. This provides a standardized, type-safe way to handle operations that can fail.

```boba
enum Result<T, E> {
  Ok(T),    // The 'Success' variant
  Err(E)    // The 'Failure' variant
}

fn load_config(): Result<Config, error> {
    // ...
}
```